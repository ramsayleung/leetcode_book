<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode Book</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/</link><description>Recent content on Leetcode Book</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ramsayleung.github.io/leetcode_book/docs/100/index.xml" rel="self" type="application/rss+xml"/><item><title>141. Linked list cycle</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</link><pubDate>Tue, 28 Apr 2020 09:04:58 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</guid><description>1 Description # source: https://leetcode.com/problems/linked-list-cycle/
Given a linked list, determine if it has a cycle in it.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Example 1:
Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.</description></item><item><title>143. Reorder List</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</link><pubDate>Sun, 27 Mar 2022 09:55:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</guid><description>1 Description # source: https://leetcode.com/problems/reorder-list/ You are given the head of a singly linked-list. The list can be represented as:
L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list&amp;rsquo;s nodes. Only nodes themselves may be changed.</description></item><item><title>162. Find Peak Element</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</link><pubDate>Sat, 16 Apr 2022 09:02:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</guid><description>1 Description # source: https://leetcode.com/problems/find-peak-element/
A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in O(log n) time.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description></item><item><title>167. Two Sum II - Input Array Is Sorted</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Tue, 03 May 2022 09:01:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/167_two_sum_ii_input_array_is_sorted/</guid><description>1 Description # source: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</description></item><item><title>190. Reverse Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</link><pubDate>Sun, 10 Apr 2022 20:45:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</guid><description>1 Description # source: https://leetcode.com/problems/reverse-bits/
Reverse bits of a given 32 bits unsigned integer.
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2&amp;rsquo;s complement notation.</description></item><item><title>191. Number of 1 Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</link><pubDate>Sun, 10 Apr 2022 20:18:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</guid><description>1 Description # source: https://leetcode.com/problems/number-of-1-bits/
Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned.</description></item></channel></rss>