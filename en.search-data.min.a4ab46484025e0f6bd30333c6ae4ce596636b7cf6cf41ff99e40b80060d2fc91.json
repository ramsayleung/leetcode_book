[{"id":0,"href":"/docs/000/2_add_two_numbers/","title":"2. Add two number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807. 2 Solution #  Solution in Python3:\n# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None  # Runtime: 72 ms, faster than 62.00% of Python3 online submissions for Add Two Numbers. # time complexity: O(n1+n2), n1 is the length of l1, n2 is the length of l2 # space complexity: O(max(n1,n2)), the length of sum of two number equals the larger\u0026#39;s   class Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: \tnum1 = self.getNumber(l1) \tnum2 = self.getNumber(l2) \tresult = num1+num2 \treturn self.constructNumber(result)   def getNumber(self, llist: ListNode) -\u0026gt; int: \tnum = \u0026#34;\u0026#34; \twhile llist: \tnum = str(llist.val) + num \tllist = llist.next \treturn int(num)   def constructNumber(self, num: int) -\u0026gt; ListNode: \tprint(num) \tinput = str(num) \tparent = root = None \twhile len(input) \u0026gt; 0: \tval = input[len(input)-1] \tnewNode = ListNode(int(val)) \tif not parent: \tparent = newNode \troot = parent \telse: \tparent.next = newNode \tparent = newNode \tinput = input[:len(input)-1] \treturn root Solution in C++:\n  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {  // Runtime complexity O(n), n = max(l1.size(), l2.size())  // Space complexity O(1)   ListNode *result = l1;  ListNode *prev = nullptr;  int carry = 0;  while (l1 \u0026amp;\u0026amp; l2) {  int add_result = l1-\u0026gt;val + l2-\u0026gt;val + carry;  if (add_result % 10 == add_result) { \tl1-\u0026gt;val = add_result; \tcarry = 0;  } else { \tl1-\u0026gt;val = add_result % 10; \tcarry = 1;  }   prev = l1;  l1 = l1-\u0026gt;next;  l2 = l2-\u0026gt;next;  }   if (l1 || l2) {  prev-\u0026gt;next = (l1 != nullptr ? l1 : l2);  ListNode *head = prev-\u0026gt;next;   while (head) { \tint add_result = head-\u0026gt;val + carry; \tif (add_result % 10 == add_result) { \thead-\u0026gt;val = add_result; \tcarry = 0; \t} else { \thead-\u0026gt;val = add_result % 10; \tcarry = 1; \t} \tprev = head; \thead = head-\u0026gt;next;  }  } else {  if (carry != 0) { \tprev-\u0026gt;next = new ListNode(carry); \treturn result;  }  }   if (carry != 0) {  prev-\u0026gt;next = new ListNode(carry);  }   return result;  } }; "},{"id":1,"href":"/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":2,"href":"/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "},{"id":3,"href":"/docs/000/43.multiply_strings/","title":"43. Multiply String","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \u0026#34;2\u0026#34;, num2 = \u0026#34;3\u0026#34; Output: \u0026#34;6\u0026#34; Example 2:\nInput: num1 = \u0026#34;123\u0026#34;, num2 = \u0026#34;456\u0026#34; Output: \u0026#34;56088\u0026#34; Constraints:\n 1 \u0026lt;= num1.length, num2.length \u0026lt;= 200 num1 and num2 consist of digits only. Both num1 and num2 do not contain any leading zero, except the number 0 itself.  2 Solution #  A not good solution\n#include \u0026lt;cmath\u0026gt;#include \u0026lt;string\u0026gt;class Solution { public:  string multiply(string num1, string num2) {  if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) {  return \u0026#34;0\u0026#34;;  }  int size1 = num1.size();  int size2 = num2.size();  auto p_str1 = num1.c_str();  auto p_str2 = num2.c_str();  std::string final_result;  for (int j = size2 - 1; j \u0026gt;= 0; j--) {  std::string result;  for (int i = size1 - 1; i \u0026gt;= 0; i--) { \tint multiply_result = (p_str1[i] - \u0026#39;0\u0026#39;) * (p_str2[j] - \u0026#39;0\u0026#39;); \tresult = add(result, std::to_string(multiply_result) + \tstd::string(size1 - 1 - i, \u0026#39;0\u0026#39;));  }  final_result = \tadd(final_result, result + std::string(size2 - 1 - j, \u0026#39;0\u0026#39;));  }  return final_result;  }   std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) {  auto p1 = num1.c_str();  auto p2 = num2.c_str();  int size1 = num1.size();  int size2 = num2.size();  int i = 0, j = 0, k = 0;  std::string result = (size1 \u0026gt; size2 ? num1 : num2);  auto p_res = result.c_str();  int carry = 0;  for (k = result.size() - 1, i = size1 - 1, j = size2 - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = (p1[i] - \u0026#39;0\u0026#39;) + (p2[j] - \u0026#39;0\u0026#39;) + carry;  if (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0;  } else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1;  }  }   if (i \u0026gt; 0) {  for (i; i \u0026gt;= 0; i--, k--) { \tint add_result = carry + (p1[i] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else if (j \u0026gt; 0) {  for (j; j \u0026gt;= 0; j--, k--) { \tint add_result = carry + (p2[j] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else {  if (carry != 0) { \tif (k \u0026lt; 0) { \treturn \u0026#39;1\u0026#39; + result; \t} else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \treturn result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \treturn \u0026#39;1\u0026#39; + result; \t} \t}  }  }   if (carry != 0) {  if (k \u0026lt; 0) { \tresult = \u0026#39;1\u0026#39; + result;  } else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tresult = \u0026#39;1\u0026#39; + result; \t}  }  }  return result;  } }; "},{"id":4,"href":"/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* rotateRight(ListNode* head, int k) {  // time complexity: O(n)  // space complexity: O(1)   if (k == 0 || !head){  return head;  }   int size = 0;  ListNode* first = head;  ListNode* last_node = head;  while(first){  if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ \tlast_node = first;  }  first = first -\u0026gt; next;   size ++;  }   // it will be the same linked_list after rotate `size` steps  k = k % size;  if(k ==0){  return head;  }   // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head;  for(int i = 0; i \u0026lt; size - k - 1; i++){  k_minus_1 = k_minus_1 -\u0026gt;next;  }   ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr;  last_node -\u0026gt; next = head;   return k_node;  } }; "},{"id":5,"href":"/docs/000/67_add_binary/","title":"67. Add Binary","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\nInput: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; Constraints:\n 1 \u0026lt;= a.length, b.length \u0026lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.  2 Solution #    class Solution { public:  string addBinary(string a, string b) {  // runtime complexity: O(N), N = max(a.size(), b.size());  // space complexity: O(N), N = max(a.size(), b.size());  auto p_a = a.c_str();  auto p_b = b.c_str();  auto sizea = a.size();  auto sizeb = b.size();  std::string result = (sizea \u0026gt; sizeb ? a : b);  int i = 0, j = 0, k = 0;  int carry = 0;   for (i = sizea - 1, j = sizeb - 1, k = result.size() - 1; i \u0026gt;= 0 || j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = 0;  if (i \u0026gt;= 0) { \tadd_result += p_a[i] - \u0026#39;0\u0026#39;;  }  if (j \u0026gt;= 0) { \tadd_result += p_b[j] - \u0026#39;0\u0026#39;;  }   add_result += carry;  if (add_result % 2 == add_result) { \tresult[k] = add_result + \u0026#39;0\u0026#39;; \tcarry = 0;  } else { \tresult[k] = add_result % 2 + \u0026#39;0\u0026#39;; \tcarry = 1;  }  }   if (carry != 0) {  result = \u0026#39;1\u0026#39; + result;  }  return result;  } }; "},{"id":6,"href":"/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution:  def hasCycle(self, head: ListNode) -\u0026gt; bool: \tseen = set() \twhile head: \tif head in seen: \treturn True \tseen.add(head) \thead = head.next \treturn False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public:  bool hasCycle(ListNode *head) {  // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){  return false;  }   ListNode* fast = head -\u0026gt; next;  while(head){  // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ \treturn true;  }   if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ \tfast = fast-\u0026gt;next-\u0026gt;next;  } else{ \t// if there is a cycle, the fast-\u0026gt; next will never be null \treturn false;  }   head = head-\u0026gt;next;  }   return false;  } }; "}]