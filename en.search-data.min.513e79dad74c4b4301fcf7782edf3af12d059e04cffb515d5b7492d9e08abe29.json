[{"id":0,"href":"/docs/000/2_add_two_numbers/","title":"2. Add two number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807. 2 Solution #  Solution in Python3:\n# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None  # Runtime: 72 ms, faster than 62.00% of Python3 online submissions for Add Two Numbers. # time complexity: O(n1+n2), n1 is the length of l1, n2 is the length of l2 # space complexity: O(max(n1,n2)), the length of sum of two number equals the larger\u0026#39;s   class Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: \tnum1 = self.getNumber(l1) \tnum2 = self.getNumber(l2) \tresult = num1+num2 \treturn self.constructNumber(result)   def getNumber(self, llist: ListNode) -\u0026gt; int: \tnum = \u0026#34;\u0026#34; \twhile llist: \tnum = str(llist.val) + num \tllist = llist.next \treturn int(num)   def constructNumber(self, num: int) -\u0026gt; ListNode: \tprint(num) \tinput = str(num) \tparent = root = None \twhile len(input) \u0026gt; 0: \tval = input[len(input)-1] \tnewNode = ListNode(int(val)) \tif not parent: \tparent = newNode \troot = parent \telse: \tparent.next = newNode \tparent = newNode \tinput = input[:len(input)-1] \treturn root Solution in C++:\n  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { \t// Runtime complexity O(n), n = max(l1.size(), l2.size()) \t// Space complexity O(1)  \tListNode* result = l1; \tListNode* prev = nullptr; \tint carry = 0; \twhile(l1 || l2){ \tint add_result = 0; \tif (l1){ \tadd_result += l1 -\u0026gt; val; \t}  \tif (l2){ \tadd_result += l2 -\u0026gt; val; \t} \tadd_result += carry;  \tListNode* head = (l1 != nullptr? l1: l2);  \tif(add_result % 10 == add_result){ \thead -\u0026gt; val = add_result; \tcarry =0; \t}else{ \thead -\u0026gt; val = add_result % 10; \tcarry =1; \t}  \tif(!prev){ \tprev = l1; \t}else{ \tprev-\u0026gt; next = head; \tprev = prev -\u0026gt; next; \t}  \tl1 = l1 != nullptr? l1 -\u0026gt; next: l1; \tl2 = l2 != nullptr? l2 -\u0026gt; next: l2; \t}  \tif(carry !=0 ){ \tprev -\u0026gt; next = new ListNode(carry); \t}  \treturn result;  } }; "},{"id":1,"href":"/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":2,"href":"/docs/000/12_integer_to_roman/","title":"12. Integer to Roman","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/integer-to-roman/\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral.\nExample 1:\nInput: num = 3 Output: \u0026#34;III\u0026#34; Explanation: 3 is represented as 3 ones. Example 2:\nInput: num = 58 Output: \u0026#34;LVIII\u0026#34; Explanation: L = 50, V = 5, III = 3. Example 3:\nInput: num = 1994 Output: \u0026#34;MCMXCIV\u0026#34; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n 1 \u0026lt;= num \u0026lt;= 3999  2 Solution #  #include \u0026lt;sstream\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;vector\u0026gt;class Solution { public:  string intToRoman(int num) { \t// Runtime complexity: O(n), n is time to divide num. \t// Space complexity: O(n) \tstatic std::vector\u0026lt;std::pair\u0026lt;std::string, int\u0026gt;\u0026gt; rimap{ \t{\u0026#34;M\u0026#34;, 1000}, \t{\u0026#34;CM\u0026#34;, 900}, \t{\u0026#34;D\u0026#34;, 500}, \t{\u0026#34;CD\u0026#34;, 400}, \t{\u0026#34;C\u0026#34;, 100}, \t{\u0026#34;XC\u0026#34;, 90}, \t{\u0026#34;L\u0026#34;, 50}, \t{\u0026#34;XL\u0026#34;, 40}, \t{\u0026#34;X\u0026#34;, 10}, \t{\u0026#34;IX\u0026#34;, 9}, \t{\u0026#34;V\u0026#34;, 5}, \t{\u0026#34;IV\u0026#34;, 4}, \t{\u0026#34;I\u0026#34;, 1} \t};  \tstd::stringstream result; \twhile(num \u0026gt; 0){ \tfor(auto iter = rimap.begin(); iter != rimap.end(); iter++){ \tif(num \u0026gt;= iter-\u0026gt;second){ \tint times = num / iter-\u0026gt; second; \trepeat(times, iter-\u0026gt;first, result); \tnum = num % iter-\u0026gt;second; \t} \t} \t} \treturn result.str();  }   void repeat(int times, const std::string\u0026amp; source, std::stringstream\u0026amp; stream){ \twhile(times \u0026gt; 0){ \tstream \u0026lt;\u0026lt; source; \ttimes --; \t}  } }; "},{"id":3,"href":"/docs/000/17_letter_combinations_of_a_phone_number/","title":"17. Letter Combinations of a Phone Number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/letter-combinations-of-a-phone-number/\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n Example:\nInput: \u0026#34;23\u0026#34; Output: [\u0026#34;ad\u0026#34;, \u0026#34;ae\u0026#34;, \u0026#34;af\u0026#34;, \u0026#34;bd\u0026#34;, \u0026#34;be\u0026#34;, \u0026#34;bf\u0026#34;, \u0026#34;cd\u0026#34;, \u0026#34;ce\u0026#34;, \u0026#34;cf\u0026#34;]. Note:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\n2 Solution #  from typing import List   # Runtime: 28 ms, faster than 70.44% of Python3 online submissions for Letter Combinations of a Phone Number. # time complexity: O(4^n), because \u0026#34;7\u0026#34; and \u0026#34;9\u0026#34; have four letters. # space complexity: O(4^n) class Solution:  def letterCombinations(self, digits: str) -\u0026gt; List[str]: \tmapping = {} \tmapping[\u0026#34;2\u0026#34;] = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] \tmapping[\u0026#34;3\u0026#34;] = [\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] \tmapping[\u0026#34;4\u0026#34;] = [\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;] \tmapping[\u0026#34;5\u0026#34;] = [\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;] \tmapping[\u0026#34;6\u0026#34;] = [\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;] \tmapping[\u0026#34;7\u0026#34;] = [\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;] \tmapping[\u0026#34;8\u0026#34;] = [\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;] \tmapping[\u0026#34;9\u0026#34;] = [\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;]  \tdef backtracking(combination: str, digits: str, output: List[str]) -\u0026gt; None: \tif len(digits) == 0: \toutput.append(combination) \treturn \tfor letter in mapping[digits[0]]: \tbacktracking(combination+letter, digits[1:], output) \toutput = [] \tif len(digits) \u0026gt; 0: \tbacktracking(\u0026#34;\u0026#34;, digits, output) \treturn output #include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt;class Solution { public:  vector\u0026lt;string\u0026gt; letterCombinations(string digits) { \t// Time complexity: O(3 ^ N), N is the size of digits \t// Space complexity: O(3 ^ N) \t// faster than 100.00% of C++ online submissions for Letter Combinations of a Phone Number. \tstd::vector\u0026lt;std::string\u0026gt; result; \tstd::vector\u0026lt;std::string\u0026gt; comb; \tbacktrack(digits, 0, 0, result, comb); \treturn result;  }   void backtrack(const std::string\u0026amp; digits, int digit_start, int letter_start, std::vector\u0026lt;std::string\u0026gt;\u0026amp; result, std::vector\u0026lt;std::string\u0026gt;\u0026amp; comb){ \tstatic std::unordered_map\u0026lt;char, std::vector\u0026lt;std::string\u0026gt;\u0026gt; letter_map{ \t{\u0026#39;2\u0026#39;, {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;}}, \t{\u0026#39;3\u0026#39;, {\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;}}, \t{\u0026#39;4\u0026#39;, {\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;}}, \t{\u0026#39;5\u0026#39;, {\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;}}, \t{\u0026#39;6\u0026#39;, {\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;}}, \t{\u0026#39;7\u0026#39;, {\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;}}, \t{\u0026#39;8\u0026#39;, {\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;}}, \t{\u0026#39;9\u0026#39;, {\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;}}  \t};  \tif(!digits.empty() \u0026amp;\u0026amp; comb.size() == digits.size()){ \tresult.push_back(vec2str(comb)); \t}  \tfor(int i = digit_start; i\u0026lt; digits.size(); i++){ \tchar c = digits.c_str()[i]; \tfor(int j = 0; j \u0026lt; letter_map[c].size(); j++){ \tcomb.push_back(letter_map[c][j]); \tbacktrack(digits, i + 1, j, result, comb); \tcomb.pop_back(); \t} \t}  }   std::string vec2str(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; comb){ \tstd::string result; \tfor(const auto\u0026amp; s: comb){ \tresult += s; \t} \treturn result;  } }; "},{"id":4,"href":"/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "},{"id":5,"href":"/docs/000/24_swap_nodes_in_pairs/","title":"24. Swap Nodes in Pairs","section":"0th","content":"1 Description #  Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\n Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1] Constraints:\n The number of nodes in the list is in the range [0, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapPairs(ListNode* head) {  // Time complexity: O(N) N = S / 2, S is the length of linked-list  // Space Complexity: O(1)  if(!head || !head-\u0026gt;next){  return head;  }   ListNode* result = head-\u0026gt;next;  ListNode* prev = nullptr;  while(head){  auto right = head-\u0026gt;next;  if(right){ \thead-\u0026gt;next = right-\u0026gt;next; \tright-\u0026gt;next = head; \tif (prev){ \tprev-\u0026gt;next = right; \t}  }   prev = head;  head= head-\u0026gt;next;  }   return result;  } }; "},{"id":6,"href":"/docs/000/26_remove_duplicates_from_sorted_array/","title":"26. Remove Duplicates from Sorted Array","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length  int k = removeDuplicates(nums); // Calls your implementation  assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) {  assert nums[i] == expectedNums[i];  } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order.  2 Soltuion #  Even though it works, it\u0026rsquo;s not a good solution\nclass Solution { public:  int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  if(nums.size() == 0){  return 0;  }   int prev = -101;  auto iter = nums.begin();   while(iter != nums.end()){  if(prev == *iter){ \tstd::remove(iter, nums.end(), prev);  }   if(*iter == *(nums.end() - 1)){ \treturn iter - nums.begin() + 1;  }   prev = *iter;  iter++;  }   return iter - nums.begin() + 1;  } }; "},{"id":7,"href":"/docs/000/33_search_in_rotated_sorted_array/","title":"33. Search in Rotated Sorted Array","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/search-in-rotated-sorted-array/\nThere is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Example 3:\nInput: nums = [1], target = 0 Output: -1 Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 5000 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 All values of nums are unique. nums is an ascending array that is possibly rotated. -10^4 \u0026lt;= target \u0026lt;= 10^4  2 Solution #  class Solution { public:  int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { \tint low = 0; \tint high = nums.size() - 1; \twhile(low \u0026lt;= high){ \tint mid = (low + high) / 2; \tif(nums[mid] == target){ \treturn mid; \t}  \t// the left half is sorted \tif(nums[mid] \u0026gt;= nums[low]){ \tif(target \u0026lt;= nums[mid] \u0026amp;\u0026amp; nums[low] \u0026lt;= target ){ \thigh = mid - 1; \t}else{ \tlow = mid + 1; \t} \t}else{ \tif(target \u0026lt;= nums[high] \u0026amp;\u0026amp; nums[mid] \u0026lt;= target){ \tlow = mid + 1; \t}else{ \thigh = mid - 1; \t} \t} \t}  \treturn -1;  } }; "},{"id":8,"href":"/docs/000/34_find_first_and_last_position_of_element_in_sorted_array/","title":"34. Find First and Last Position of Element in Sorted Array","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nYour algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n).\nIf the target is not found in the array, return [-1, -1].\nExample 1:\n Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2:\nInput: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] 2 Solution #  # Runtime: 80 ms, faster than 95.74% of Python3 online submissions for Find First and Last Position of Element in Sorted Array. # time complexity: O(2*logn)-\u0026gt;O(logn), 2 is because we search twice. # space complexity: O(1) class Solution:  def searchRange(self, nums: List[int], target: int) -\u0026gt; List[int]: \tif len(nums) == 0: \treturn [-1,-1] \t# 找出最左边等于target的元素的位置 \tbinarySearchLeft = lambda x,y: x\u0026lt;y \t# 找出最左边大于target的元素的位置 x, 若 nums[x] 刚大于target, 那么 \t# nums[x-1] 就是最右边等于target的元素. \tbinarySearchRight = lambda x,y: x\u0026lt;=y \tdef binarySearch(condition)-\u0026gt;int: \tlow = 0 \thigh = len(nums) \twhile low \u0026lt; high: \tmid = (low+high) // 2 \tif condition(nums[mid],target): \tlow = mid + 1 \telse: \thigh = mid \treturn low \tfirst = binarySearch(binarySearchLeft) \tlast = binarySearch(binarySearchRight) - 1 \treturn [first, last] if first\u0026lt;len(nums) and nums[first] == target else [-1,-1] #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) {  // Space complexity: O(1)  // Time complexity: O(2 logN) =\u0026gt; O(logN)  if(0 == nums.size()){  std::vector\u0026lt;int\u0026gt; result{-1, -1};  return result;  }   auto low = std::lower_bound(nums.begin(), nums.end(), target);  if(low == nums.end() || *low != target){  std::vector\u0026lt;int\u0026gt; result{-1, -1};  return result;  }   auto high = std::upper_bound(low, nums.end(), target);  std::vector\u0026lt;int\u0026gt; result{static_cast\u0026lt;int\u0026gt;(low - nums.begin()), static_cast\u0026lt;int\u0026gt;(high - nums.begin() - 1)};  return result;  } }; "},{"id":9,"href":"/docs/000/35.search_insert_position/","title":"35. Search Insert Position","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/search-insert-position/\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5 Output: 2 Example 2:\nInput: nums = [1,3,5,6], target = 2 Output: 1 Example 3:\nInput: nums = [1,3,5,6], target = 7 Output: 4 Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 10**4 10**4 \u0026lt;= nums[i] \u0026lt;= 10**4 nums contains distinct values sorted in ascending order. 10**4 \u0026lt;= target \u0026lt;= 10**4  2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { \treturn std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();  } }; "},{"id":10,"href":"/docs/000/43.multiply_strings/","title":"43. Multiply String","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \u0026#34;2\u0026#34;, num2 = \u0026#34;3\u0026#34; Output: \u0026#34;6\u0026#34; Example 2:\nInput: num1 = \u0026#34;123\u0026#34;, num2 = \u0026#34;456\u0026#34; Output: \u0026#34;56088\u0026#34; Constraints:\n 1 \u0026lt;= num1.length, num2.length \u0026lt;= 200 num1 and num2 consist of digits only. Both num1 and num2 do not contain any leading zero, except the number 0 itself.  2 Solution #  A not good solution\n#include \u0026lt;cmath\u0026gt;#include \u0026lt;string\u0026gt;class Solution { public:  string multiply(string num1, string num2) {  if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) {  return \u0026#34;0\u0026#34;;  }  int size1 = num1.size();  int size2 = num2.size();  auto p_str1 = num1.c_str();  auto p_str2 = num2.c_str();  std::string final_result;  for (int j = size2 - 1; j \u0026gt;= 0; j--) {  std::string result;  for (int i = size1 - 1; i \u0026gt;= 0; i--) { \tint multiply_result = (p_str1[i] - \u0026#39;0\u0026#39;) * (p_str2[j] - \u0026#39;0\u0026#39;); \tresult = add(result, std::to_string(multiply_result) + \tstd::string(size1 - 1 - i, \u0026#39;0\u0026#39;));  }  final_result = \tadd(final_result, result + std::string(size2 - 1 - j, \u0026#39;0\u0026#39;));  }  return final_result;  }   std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) {  auto p1 = num1.c_str();  auto p2 = num2.c_str();  int size1 = num1.size();  int size2 = num2.size();  int i = 0, j = 0, k = 0;  std::string result = (size1 \u0026gt; size2 ? num1 : num2);  auto p_res = result.c_str();  int carry = 0;  for (k = result.size() - 1, i = size1 - 1, j = size2 - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = (p1[i] - \u0026#39;0\u0026#39;) + (p2[j] - \u0026#39;0\u0026#39;) + carry;  if (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0;  } else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1;  }  }   if (i \u0026gt; 0) {  for (i; i \u0026gt;= 0; i--, k--) { \tint add_result = carry + (p1[i] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else if (j \u0026gt; 0) {  for (j; j \u0026gt;= 0; j--, k--) { \tint add_result = carry + (p2[j] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else {  if (carry != 0) { \tif (k \u0026lt; 0) { \treturn \u0026#39;1\u0026#39; + result; \t} else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \treturn result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \treturn \u0026#39;1\u0026#39; + result; \t} \t}  }  }   if (carry != 0) {  if (k \u0026lt; 0) { \tresult = \u0026#39;1\u0026#39; + result;  } else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tresult = \u0026#39;1\u0026#39; + result; \t}  }  }  return result;  } }; "},{"id":11,"href":"/docs/000/54_spiral_matrix/","title":"54. Spiral Matrix","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/spiral-matrix/\nGiven an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\n Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2:\n Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints:\n m == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 10 -100 \u0026lt;= matrix[i][j] \u0026lt;= 100  2 Solution #  #include \u0026lt;iostream\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) {  // Time complexity: O(m * n)  // Space complexity: O(m * n)   int m = matrix.size();  int n = matrix[0].size();  int left = 0, right = n -1;  int up = 0, down = m - 1;  int j = 0;  std::vector\u0026lt;int\u0026gt; result;  result.reserve(m * n); // this single statement makes this solution faster than 100.00% of C++ online submissions   while(j \u0026lt; m * n){  for(int i = left; i \u0026lt;= right \u0026amp;\u0026amp; j \u0026lt; m *n; i++, j++){ \tresult.push_back(matrix[up][i]);  }   for(int i = up + 1; i\u0026lt;= down \u0026amp;\u0026amp; j \u0026lt; m* n; i++, j++){ \tresult.push_back(matrix[i][right]);  }   for(int i = right - 1; i\u0026gt;=left \u0026amp;\u0026amp; j \u0026lt; m * n; i--, j++){ \tresult.push_back(matrix[down][i]);  }   for(int i = down - 1; i \u0026gt; up \u0026amp;\u0026amp; j \u0026lt; m*n; i--, j++){ \tresult.push_back(matrix[i][left]);  }   left++, right--, up++, down--;  }  return result;  } }; "},{"id":12,"href":"/docs/000/merge_intervals/","title":"56. Merge Intervals","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/merge-intervals/\nGiven a collection of intervals, merge all overlapping intervals.\nExample 1:\nInput: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:\nInput: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n2 Solution #  from typing import List # time complexity: O(nlogn), time to sort intervals. # space complexity: O(1) class Solution:  def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: \tsize = len(intervals) \tif size \u0026lt;=1: \treturn intervals \t# sorted \tmerged = [] \tintervals.sort(key = lambda x: x[0]) \tfor interval in intervals: \tif not merged or merged[-1][1]\u0026lt;interval[0]: \tmerged.append(interval) \telse: \tmerged[-1][1] = max(merged[-1][1], interval[1]) \treturn merged #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) {  std::sort(intervals.begin(), intervals.end());   std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; merged;  for(const auto\u0026amp; interval: intervals){  if(merged.empty() || merged.back()[1] \u0026lt; interval[0]){ \tmerged.push_back(interval);  }else{ \t// there is an overlap \tmerged.back()[1] = std::max(merged.back()[1], interval[1]);  }  }   return merged;  } }; "},{"id":13,"href":"/docs/000/57_insert_interval/","title":"57. Insert Interval","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/insert-interval/\nYou are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints:\n 0 \u0026lt;= intervals.length \u0026lt;= 10^4 intervals[i].length == 2 0 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 10^5 intervals is sorted by starti in ascending order. newInterval.length == 2 0 \u0026lt;= start \u0026lt;= end \u0026lt;= 10^5  2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; insert(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals, vector\u0026lt;int\u0026gt;\u0026amp; newInterval) {  // Space complexity: O(N), N is the size of intervals  // Time complexity: O(N) \tstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; merged; \tfor(auto iter = intervals.begin(); iter != intervals.end(); iter++){ \tauto interval = *iter; \t// the newInterval is less than the current interval, since the intervals is in ascending order, therefore there is no chance to have overlapping any more, just return \tif(newInterval[1] \u0026lt; interval[0]){ \tmerged.push_back(newInterval); \tstd::copy(iter, intervals.end(), std::back_inserter(merged)); \treturn merged; \t}else if(interval[1] \u0026lt; newInterval[0]){ \t// There is no overlapping here since the left value of newInterval is greater than the right value of interval. \tmerged.push_back(interval); \t}else{ \t// Create a new `newInterval` with maximium range. \tnewInterval = {std::min(newInterval[0], interval[0]), std::max(newInterval[1], interval[1])}; \t} \t}  \tmerged.push_back(newInterval);  \treturn merged;  } }; "},{"id":14,"href":"/docs/000/58_length_of_last_word/","title":"58. Length of Last Word","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/length-of-last-word/\nGiven a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \u0026#34;Hello World\u0026#34; Output: 5 Explanation: The last word is \u0026#34;World\u0026#34; with length 5. Example 2:\nInput: s = \u0026#34; fly me to the moon \u0026#34; Output: 4 Explanation: The last word is \u0026#34;moon\u0026#34; with length 4. Example 3:\nInput: s = \u0026#34;luffy is still joyboy\u0026#34; Output: 6 Explanation: The last word is \u0026#34;joyboy\u0026#34; with length 6. Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 10^4 s consists of only English letters and spaces ' '. There will be at least one word in s.  2 Solution #  class Solution { public:  int lengthOfLastWord(string s) { \t// Time complexity: O(N), N is the size of s \t// Space complexity: O(1) \t// faster than 100.00% of C++ \tint last_index = s.size() - 1; \twhile(last_index \u0026gt;= 0 \u0026amp;\u0026amp; s[last_index] == \u0026#39; \u0026#39;){ \tlast_index--; \t}  \tint length = 0; \twhile(last_index \u0026gt;=0 \u0026amp;\u0026amp; s[last_index] != \u0026#39; \u0026#39;){ \tlength ++; \tlast_index --; \t}  \treturn length;  } }; "},{"id":15,"href":"/docs/000/59_spiral_matrix_ii/","title":"59. Spiral Matrix II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/spiral-matrix-ii/ Given a positive integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order.\nExample 1:\n Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Example 2:\nInput: n = 1 Output: [[1]] Constraints:\n 1 \u0026lt;= n \u0026lt;= 20  2 Solution #  class Solution { public:   vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { \t// Space complexity: O(n * n) \t// Time complexity: O(n * n) \t// faster than 100.00% of C++ online submissions for Spiral Matrix II  \tstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result; \tresult.reserve(n); \tfor(int i = 0; i\u0026lt; n; i++){ \tstd::vector\u0026lt;int\u0026gt; init(n, 0); \tresult.push_back(init); \t}  \tint up = 0, down = n - 1, left = 0, right = n - 1; \tint j = 0;  \twhile(j \u0026lt; n * n){ \tfor(int i = left; i \u0026lt;= right \u0026amp;\u0026amp; j \u0026lt; n*n; i++){ \tresult[up][i] = ++j; \t}  \tfor(int i = up + 1; i \u0026lt;= down \u0026amp;\u0026amp; j \u0026lt; n *n; i++){ \tresult[i][right] = ++j; \t}  \tfor(int i = right - 1; i \u0026gt;= left \u0026amp;\u0026amp; j \u0026lt; n * n; i--){ \tresult[down][i] = ++j; \t}  \tfor(int i = down - 1; i \u0026gt; up \u0026amp;\u0026amp; j \u0026lt; n * n; i--){ \tresult[i][left] = ++j; \t}  \tleft++, right--, up++, down--; \t}  \treturn result;  } }; "},{"id":16,"href":"/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* rotateRight(ListNode* head, int k) {  // time complexity: O(n)  // space complexity: O(1)   if (k == 0 || !head){  return head;  }   int size = 0;  ListNode* first = head;  ListNode* last_node = head;  while(first){  if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ \tlast_node = first;  }  first = first -\u0026gt; next;   size ++;  }   // it will be the same linked_list after rotate `size` steps  k = k % size;  if(k ==0){  return head;  }   // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head;  for(int i = 0; i \u0026lt; size - k - 1; i++){  k_minus_1 = k_minus_1 -\u0026gt;next;  }   ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr;  last_node -\u0026gt; next = head;   return k_node;  } }; "},{"id":17,"href":"/docs/000/67_add_binary/","title":"67. Add Binary","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\nInput: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; Constraints:\n 1 \u0026lt;= a.length, b.length \u0026lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.  2 Solution #    class Solution { public:  string addBinary(string a, string b) {  // runtime complexity: O(N), N = max(a.size(), b.size());  // space complexity: O(N), N = max(a.size(), b.size());  auto p_a = a.c_str();  auto p_b = b.c_str();  auto sizea = a.size();  auto sizeb = b.size();  std::string result = (sizea \u0026gt; sizeb ? a : b);  int i = 0, j = 0, k = 0;  int carry = 0;   for (i = sizea - 1, j = sizeb - 1, k = result.size() - 1; i \u0026gt;= 0 || j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = 0;  if (i \u0026gt;= 0) { \tadd_result += p_a[i] - \u0026#39;0\u0026#39;;  }  if (j \u0026gt;= 0) { \tadd_result += p_b[j] - \u0026#39;0\u0026#39;;  }   add_result += carry;  if (add_result % 2 == add_result) { \tresult[k] = add_result + \u0026#39;0\u0026#39;; \tcarry = 0;  } else { \tresult[k] = add_result % 2 + \u0026#39;0\u0026#39;; \tcarry = 1;  }  }   if (carry != 0) {  result = \u0026#39;1\u0026#39; + result;  }  return result;  } }; "},{"id":18,"href":"/docs/000/71_simplify_path/","title":"71. Simplify Path","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/simplify-path/\nGiven a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\nIn a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\nThe canonical path should have the following format:\n The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')  Return the simplified canonical path.\nExample 1:\nInput: path = \u0026#34;/home/\u0026#34; Output: \u0026#34;/home\u0026#34; Explanation: Note that there is no trailing slash after the last directory name. Example 2:\nInput: path = \u0026#34;/../\u0026#34; Output: \u0026#34;/\u0026#34; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3:\nInput: path = \u0026#34;/home//foo/\u0026#34; Output: \u0026#34;/home/foo\u0026#34; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints:\n 1 \u0026lt;= path.length \u0026lt;= 3000 path consists of English letters, digits, period '.', slash '/' or '_'. path is a valid absolute Unix path.  2 Solution #  #include \u0026lt;vector\u0026gt;#include \u0026lt;sstream\u0026gt;class Solution { public:  string simplifyPath(string path) { \t// Space complexity: O(D), D is the depth of path. \t// Time complexity: O(D), D is the depth of path.  \tstd::istringstream is(path); \tstd::string token; \tstd::vector\u0026lt;std::string\u0026gt; result{\u0026#34;/\u0026#34;}; \twhile(std::getline(is, token, \u0026#39;/\u0026#39;)){ \tif(token == \u0026#34;\u0026#34;){ \tcontinue; \t}  \tif(result.back() != \u0026#34;/\u0026#34;){ \tresult.push_back(\u0026#34;/\u0026#34;); \t}  \tif(token == \u0026#34;..\u0026#34;){ \tint pop_times = 0;  \twhile(result.size() \u0026gt; 1 \u0026amp;\u0026amp; pop_times \u0026lt; 3){ \tresult.pop_back(); \tpop_times++; \t} \t}else if(token == \u0026#34;.\u0026#34;){ \tif(result.size() \u0026gt; 1){ \tresult.pop_back(); \t} \t}else{ \tresult.push_back(token); \t} \t}  \tstd::stringstream ss; \tfor(const auto\u0026amp; path: result){ \tss \u0026lt;\u0026lt; path; \t} \treturn ss.str();  } }; "},{"id":19,"href":"/docs/000/73_set_matrix_zeroes/","title":"73. Set Matrix Zeroes","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/set-matrix-zeroes/\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s.\nYou must do it in place.\nExample 1:\n Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:\n Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Constraints:\n m == matrix.length n == matrix[0].length 1 \u0026lt;= m, n \u0026lt;= 200 -2^31 \u0026lt;= matrix[i][j] \u0026lt;= 2^31 - 1  Follow up:\n A straightforward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?  2 Solution #  #include \u0026lt;unordered_set\u0026gt;class Solution { public:  void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { \t// Space complexity: O(m + n) \t// Time complexity: O(2 * m *n ) =\u0026gt; O(m * n) \tint m = matrix.size(); \tint n = matrix[0].size(); \tstd::unordered_set\u0026lt;int\u0026gt; rows; \tstd::unordered_set\u0026lt;int\u0026gt; cols; \tfor(int i = 0; i\u0026lt;m;i ++){ \tfor(int j = 0; j \u0026lt; n; j++){ \tif(matrix[i][j] == 0){ \trows.insert(i); \tcols.insert(j); \t} \t} \t}  \tfor(int i = 0; i\u0026lt;m;i ++){ \tfor(int j = 0; j \u0026lt; n; j++){ \tif(cols.count(j) != 0 || rows.count(i) != 0){ \tmatrix[i][j] = 0; \t} \t} \t}  } }; "},{"id":20,"href":"/docs/000/75_sort_colors/","title":"75. Sort Colors","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/sort-colors/\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2:\nInput: nums = [2,0,1] Output: [0,1,2] Constraints:\n n == nums.length 1 \u0026lt;= n \u0026lt;= 300 nums[i] is either 0, 1, or 2.  Follow up: Could you come up with a one-pass algorithm using only constant extra space?\n2 Solution #  class Solution { public:  void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  // Time complexity: O(2N) =\u0026gt; O(N), N is the size of nums  // Space complexity: O(1)  int red_cnt = 0;  int white_cnt = 0;  int blue_cnt = 0;  for(const auto\u0026amp; color: nums){  if(0 == color){ \tred_cnt++;  }else if(1 == color){ \twhite_cnt ++;  }else{ \tblue_cnt ++;  }  }   for(int i = 0; i\u0026lt;nums.size(); i++){  if(red_cnt-- \u0026gt;0){ \tnums[i] = 0;  }else if(white_cnt-- \u0026gt;0){ \tnums[i] = 1;  }else{ \tnums[i] = 2; \tblue_cnt --;  }  }  } }; "},{"id":21,"href":"/docs/000/78_subsets/","title":"78. Subsets","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/subsets/\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: nums = [1,2,3] Output: [  [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ] 2 Solution #  from typing import List # Runtime: 32 ms, faster than 73.24% of Python3 online submissions for Subsets. # time complexity: O(N*2^N) to generate all subsets and then copy them into # output list # space complexity: O(2^N) 2^N subsets for the length, every subset need O(N) to store class Solution:  def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: \toutput: List[List[int]] = [] \tseen = set() \tlength = len(nums) \tdef backtracking(start: int, subset: List[int]) -\u0026gt;None: \tif start \u0026gt;= length: \toutput.append(subset.copy()) \treturn \tfor idx in range(start, length): \tif tuple(subset) not in seen: \tseen.add(tuple(subset)) \toutput.append(subset) \tif nums[idx] not in set(subset): \tbacktracking(idx+1, subset+[nums[idx]]) \tbacktracking(0, []) \treturn output class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  // faster than 100.00% of C++ online submissions for Subsets.  // Time complexity: O(N!) N is the size of nums.  // Space complexity: O(N!)  std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result;  std::vector\u0026lt;int\u0026gt; path;  backtrack(nums, 0, result, path);  return result;  } private:  void backtrack(const std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, std::vector\u0026lt;int\u0026gt;\u0026amp; path){  result.push_back(path);  for(int i = start; i \u0026lt; nums.size(); i++){  path.push_back(nums[i]);  backtrack(nums, i + 1, result, path);  path.pop_back();  }  } }; "},{"id":22,"href":"/docs/000/82_remove_duplicates_from_sorted_list_ii/","title":"82. Remove Duplicates from Sorted List II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/\nGiven the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1:\n  Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2:\n  Input: head = [1,1,1,2,3] Output: [2,3] Constraints:\n The number of nodes in the list is in the range [0, 300]. -100 \u0026lt;= Node.val \u0026lt;= 100 The list is guaranteed to be sorted in ascending order.  2 Solution #  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteDuplicates(ListNode* head) {  // Space complexity: O(1)  // Time complexity: O(N)  ListNode fake_head(0, head);  ListNode *prev = \u0026amp;fake_head;  while(head){  if(head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == head-\u0026gt;val){ \t// loop until the last node of the sublist needed to delete \t// e.g. [3, 3] \twhile(head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == head-\u0026gt;val){ \thead = head-\u0026gt;next; \t}  \t// let the `prev` node point to the next node of the last node of the subset \t// it doesn\u0026#39;t matter if the head-\u0026gt;next is duplicated either, since we could loop head-\u0026gt;next again until we find the last node of `head-next`. \tprev-\u0026gt;next = head-\u0026gt;next;  } else{ \tprev = prev-\u0026gt;next;  }   head = head-\u0026gt;next;  }   return fake_head.next;  } }; "},{"id":23,"href":"/docs/000/83_remove_duplicates_from_sorted_list/","title":"83. Remove Duplicates from Sorted List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-list/\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\n Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:\n The number of nodes in the list is in the range [0, 300]. -100 \u0026lt;= Node.val \u0026lt;= 100 The list is guaranteed to be sorted in ascending order.  2 Solution #  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteDuplicates(ListNode* head) {  // time complexity: O(N): N is size of linked list  // space compleixty: O(1)  if(!head){  return head;  }   ListNode* prev = nullptr;  ListNode* result = head;  while(head){  if(!prev){ \tprev = head; \tcontinue;  }   if(prev-\u0026gt;val != head-\u0026gt;val){ \tprev-\u0026gt;next = head; \tprev = prev-\u0026gt;next;  }else{ \t// delete the last duplicate node \tif(!head-\u0026gt;next){ \tprev -\u0026gt; next = nullptr; \treturn result; \t}  }   head = head -\u0026gt; next;  }   return result;  } }; "},{"id":24,"href":"/docs/000/86_partition_list/","title":"86. Partition List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/partition-list/\nGiven the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\n Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2:\nInput: head = [2,1], x = 2 Output: [1,2] Constraints:\n The number of nodes in the list is in the range [0, 200]. -100 \u0026lt;= Node.val \u0026lt;= 100 -200 \u0026lt;= x \u0026lt;= 200  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode *partition(ListNode *head, int x) {  // Time complexity: O(N), N is the size of linked_list  // Space complexity: O(1)  if (!head) {  return head;  }   ListNode *first_less_x = nullptr;  ListNode *last_less_x = nullptr;  ListNode *last_greater_x = nullptr;  ListNode *first_greater_x = nullptr;  while (head) {  if (head-\u0026gt;val \u0026lt; x) { \tfirst_less_x = (first_less_x == nullptr ? head : first_less_x);  \tif (!last_less_x) { \tlast_less_x = head;  \t} else { \tlast_less_x-\u0026gt;next = head; \tlast_less_x = last_less_x-\u0026gt;next; \t}  } else { \tfirst_greater_x = (first_greater_x == nullptr ? head : first_greater_x);  \tif (!last_greater_x) { \tlast_greater_x = head; \t} else { \tlast_greater_x-\u0026gt;next = head; \tlast_greater_x = last_greater_x-\u0026gt;next; \t}  }   head = head-\u0026gt;next;  }   if (last_greater_x) {  last_greater_x-\u0026gt;next = nullptr;  }   if (last_less_x) {  last_less_x-\u0026gt;next = first_greater_x;  }   return first_less_x != nullptr ? first_less_x : first_greater_x;  } }; "},{"id":25,"href":"/docs/000/88_merge_sorted_array/","title":"88. Merge Sorted Array","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/merge-sorted-array/ You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\n nums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -10^9 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 10^9  Follow up: Can you come up with an algorithm that runs in O(m + n) time?\n2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { \t// Space complexity: O(1) \t// Time complexity: O(2N + M) \tstd::copy(nums2.begin(), nums2.end(), nums1.begin() + m); \tstd::inplace_merge(nums1.begin(), nums1.begin() +m, nums1.end());  } }; "},{"id":26,"href":"/docs/000/90_subsets_ii/","title":"90. Subsets II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/subsets-ii/\nGiven an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Example 2:\nInput: nums = [0] Output: [[],[0]] Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10  2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { \t// Time complexity: O(N!), N is the size of nums \t// Space complexity: O(N!) \tstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result; \tstd::vector\u0026lt;int\u0026gt; path; \tstd::sort(nums.begin(), nums.end()); \tbacktrack(nums, 0, result, path); \treturn result;  } private:  void backtrack(const std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, std::vector\u0026lt;int\u0026gt;\u0026amp; path){ \tresult.push_back(path); \tfor(int i = start; i \u0026lt; nums.size(); i++){ \t// skip duplicate \tif(i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]){ \tcontinue; \t} \tpath.push_back(nums[i]); \tbacktrack(nums, i + 1, result, path); \tpath.pop_back(); \t}  } }; "},{"id":27,"href":"/docs/000/92_reverse_linked_list_ii/","title":"92. Reverse Linked List II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/reverse-linked-list-ii/\nGiven the head of a singly linked list and two integers left and right where left \u0026lt; right=, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\n Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2:\nInput: head = [5], left = 1, right = 1 Output: [5] Constraints:\nThe number of nodes in the list is n.\n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* reverseBetween(ListNode* head, int left, int right) {  // time complexity: O(2N), N = size of the linked list  // space compleixty: O(1)  if(!head || left == right){  return head;  }   ListNode* left_prev = nullptr;  ListNode* left_node = nullptr;  ListNode* right_node = nullptr;  ListNode* result = nullptr;   int size = 0;  while(head){  size ++;  if(!result \u0026amp;\u0026amp; size \u0026lt;= left - 1){ \tresult = head;  }  if(size == left - 1){ \tleft_prev = head;  }   if(size == left){ \tleft_node = head;  }    if(size == right){ \tright_node = head;  }   head = head-\u0026gt;next;  }   ListNode* right_node_next = right_node -\u0026gt; next;  right_node-\u0026gt; next = nullptr;  if(!result){  result = right_node;  }   while(left_node){  ListNode* left_next = left_node-\u0026gt;next;  left_node-\u0026gt;next = right_node_next;  right_node_next = left_node;  if(!left_next \u0026amp;\u0026amp; left_prev){ \tleft_prev -\u0026gt; next = left_node;  }  left_node = left_next;  }     return result;  } }; "},{"id":28,"href":"/docs/000/93_restore_ip_addresses/","title":"93. Restore IP Addresses","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/restore-ip-addresses/\nA valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n For example, \u0026quot;0.1.2.201\u0026quot; and \u0026quot;192.168.1.1\u0026quot; are valid IP addresses, but \u0026quot;0.011.255.245\u0026quot;, \u0026quot;192.168.1.312\u0026quot; and \u0026quot;192.168@1.1\u0026quot; are invalid IP addresses.  Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\nExample 1:\nInput: s = \u0026#34;25525511135\u0026#34; Output: [\u0026#34;255.255.11.135\u0026#34;,\u0026#34;255.255.111.35\u0026#34;] Example 2:\nInput: s = \u0026#34;0000\u0026#34; Output: [\u0026#34;0.0.0.0\u0026#34;] Example 3:\nInput: s = \u0026#34;101023\u0026#34; Output: [\u0026#34;1.0.10.23\u0026#34;,\u0026#34;1.0.102.3\u0026#34;,\u0026#34;10.1.0.23\u0026#34;,\u0026#34;10.10.2.3\u0026#34;,\u0026#34;101.0.2.3\u0026#34;] Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 20 s consists of digits only.  2 Solution #  #include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;cstdlib\u0026gt;class Solution { public:  vector\u0026lt;string\u0026gt; restoreIpAddresses(string s) { \t// Time complexity: O(N!), N is the size of s. \t// Space complexity: O(N!) \t// faster than 100.00% of C++ online submissions for Restore IP Addresses \tstd::vector\u0026lt;std::string\u0026gt; result; \tstd::vector\u0026lt;std::string\u0026gt; bytes; \tbacktrack(s, bytes , result); \treturn result;  }   void backtrack(const std::string\u0026amp; input, std::vector\u0026lt;std::string\u0026gt;\u0026amp; bytes, std::vector\u0026lt;std::string\u0026gt;\u0026amp; result){ \tif(input.empty() \u0026amp;\u0026amp; bytes.size() == 4){ \tstd::string ip; \tfor(const auto\u0026amp; b: bytes){ \tip = ip + b + \u0026#34;.\u0026#34;; \t} \tip.pop_back(); \tresult.push_back(ip); \t}  \tfor(int i = 1; i\u0026lt;= input.size(); i++){ \tstd::string substr = input.substr(0, i); \tif(!is_valid_ip(substr)){ \tcontinue; \t}  \t// Cut the all invalid branches \tif(bytes.size() \u0026gt; 4){ \treturn; \t}  \tbytes.push_back(substr); \tbacktrack(input.substr(i), bytes, result); \tbytes.pop_back(); \t}  }   bool is_valid_ip(const std::string\u0026amp; ip){ \tif(ip.size() \u0026gt; 1 \u0026amp;\u0026amp; ip[0] == \u0026#39;0\u0026#39;){ \treturn false; \t}  \tint digit = std::atoi(ip.c_str()); \tif(digit \u0026lt; 0 || digit \u0026gt; 255){ \treturn false; \t}  \treturn true;  } }; "},{"id":29,"href":"/docs/100/131_palindrome_partitioning/","title":"131. Palindrome Partitioning","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/palindrome-partitioning/\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nA palindrome string is a string that reads the same backward as forward.\nExample 1:\nInput: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] Example 2:\nInput: s = \u0026#34;a\u0026#34; Output: [[\u0026#34;a\u0026#34;]] Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 16 s contains only lowercase English letters.  2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { \t// Time complexity: O(N!) N is the size of s \t// Space complexity: O(N!) \tstd::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; result; \tstd::vector\u0026lt;std::string\u0026gt; partition_str; \tbacktrack(s, result, partition_str); \treturn result;  }   void backtrack(const std::string\u0026amp; input, std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt;\u0026amp; result, std::vector\u0026lt;std::string\u0026gt;\u0026amp;partition){ \tif(input.empty()){ \tresult.push_back(partition); \t}  \tfor(int i = 1; i \u0026lt;= input.size(); i++){ \tstd::string substr = input.substr(0, i); \tif(!isPalindrome(substr)){ \tcontinue; \t}  \tpartition.push_back(substr); \tbacktrack(input.substr(i), result, partition); \tpartition.pop_back(); \t}  }   bool isPalindrome(const std::string\u0026amp; input){ \tint size = input.size() ; \tint med = size/2; \tfor(int i = 0 ; i \u0026lt; med; i++){ \tif(input[i] != input[size - 1 - i]){ \treturn false; \t} \t} \treturn true;  }  }; "},{"id":30,"href":"/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution:  def hasCycle(self, head: ListNode) -\u0026gt; bool: \tseen = set() \twhile head: \tif head in seen: \treturn True \tseen.add(head) \thead = head.next \treturn False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public:  bool hasCycle(ListNode *head) {  // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){  return false;  }   ListNode* fast = head -\u0026gt; next;  while(head){  // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ \treturn true;  }   if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ \tfast = fast-\u0026gt;next-\u0026gt;next;  } else{ \t// if there is a cycle, the fast-\u0026gt; next will never be null \treturn false;  }   head = head-\u0026gt;next;  }   return false;  } }; "},{"id":31,"href":"/docs/100/143_reorder_list/","title":"143. Reorder List","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/reorder-list/ You are given the head of a singly linked-list. The list can be represented as:\nL0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list\u0026rsquo;s nodes. Only nodes themselves may be changed.\nExample 1:\n Input: head = [1,2,3,4] Output: [1,4,2,3] Example 2:\n Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] Constraints:\n The number of nodes in the list is in the range [1, 5 * 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 1000  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #include \u0026lt;deque\u0026gt;class Solution { public:  void reorderList(ListNode* head) {  // Time complexity: O(2N), N is the size of linked list  // Space complexity: O(N), N is the size of linked list  std::deque\u0026lt;ListNode*\u0026gt; head_deque;  while(head){  head_deque.push_back(head);  head = head-\u0026gt;next;  }   ListNode* prev = nullptr;  ListNode* node = nullptr;  bool first_last_flag = true;   while(!head_deque.empty()){  if(first_last_flag){ \tnode = head_deque.front(); \thead_deque.pop_front();  }else{ \tnode = head_deque.back(); \thead_deque.pop_back();  }   node -\u0026gt; next = nullptr;  first_last_flag = !first_last_flag;   if(prev){ \tprev-\u0026gt;next = node; \tprev = prev-\u0026gt;next;  }else{ \tprev = node;  }   if(!head){ \thead = node;  }  }  } }; "},{"id":32,"href":"/docs/100/151_reverse_words_in_a_string/","title":"151. Reverse Words in a String","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/reverse-words-in-a-string/\nGiven an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \u0026#34;the sky is blue\u0026#34; Output: \u0026#34;blue is sky the\u0026#34; Example 2:\nInput: s = \u0026#34; hello world \u0026#34; Output: \u0026#34;world hello\u0026#34; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:\nInput: s = \u0026#34;a good example\u0026#34; Output: \u0026#34;example good a\u0026#34; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Constraints:\n 1 \u0026lt;= s.length \u0026lt;= 10^4 s contains English letters (upper-case and lower-case), digits, and spaces ' '. There is at least one word in s.  Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?\n2 Solution #  #include \u0026lt;sstream\u0026gt;class Solution { public:  string reverseWords(string s) {  // Time complexity: O(N), N is the size of s  // Space complexity: O(N)  int last_index = s.size() - 1;   std::string result;  std::string word;  while(last_index \u0026gt;= 0){  if(s[last_index] == \u0026#39; \u0026#39;){ \tif(!word.empty()){ \tresult = result.empty() ? word : result + \u0026#34; \u0026#34; + word; \t} \tword = \u0026#34;\u0026#34;;  }else{ \tword = s[last_index] + word;  }  last_index--;  }   if(!word.empty()){  result = result.empty() ? word : result + \u0026#34; \u0026#34; + word;  }   return result;  } }; "},{"id":33,"href":"/docs/100/162_find_peak_element/","title":"162. Find Peak Element","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/find-peak-element/\nA peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2:\nInput: nums = [1,2,1,3,5,6,4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 1000 -2^31 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1 nums[i] != nums[i + 1] for all valid i.  2 Solution #  class Solution { public:  int findPeakElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  // Time complexity: O(logN)  // Space complexity: O(1)  int low = 0;  int high = nums.size();  int mid = 0;  while (low \u0026lt;= high) {  mid = (low + high) / 2;  if (mid != 0 \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid - 1]) { \thigh = mid - 1;  } else if (mid != nums.size() - 1 \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid + 1]) { \tlow = mid + 1;  } else { \treturn mid;  }  }   return mid;  } }; "},{"id":34,"href":"/docs/100/167_two_sum_ii_input_array_is_sorted/","title":"167. Two Sum II - Input Array Is Sorted","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\nGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n 2 \u0026lt;= numbers.length \u0026lt;= 3 * 10^4 -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 numbers is sorted in non-decreasing order. -1000 \u0026lt;= target \u0026lt;= 1000 The tests are generated such that there is exactly one solution.  2 Solution #  #include \u0026lt;algorithm\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) {  // Space complexity: O(1)  // Time complexity: O(N)  int low = 0;  int high = numbers.size() - 1;  while(numbers[low] + numbers[high] != target){  if(numbers[low] + numbers[high] \u0026lt; target){ \tlow ++;  }else{ \thigh--;  }  }   std::vector\u0026lt;int\u0026gt; result{low + 1, high + 1};  return result;  } }; "},{"id":35,"href":"/docs/100/171_excel_sheet_column_number/","title":"171. Excel Sheet Column Number","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/excel-sheet-column-number/\nGiven a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\nFor example:\nA -\u0026gt; 1 B -\u0026gt; 2 C -\u0026gt; 3 ... Z -\u0026gt; 26 AA -\u0026gt; 27 AB -\u0026gt; 28 ... Example 1:\nInput: columnTitle = \u0026#34;A\u0026#34; Output: 1 Example 2:\nInput: columnTitle = \u0026#34;AB\u0026#34; Output: 28 Example 3:\nInput: columnTitle = \u0026#34;ZY\u0026#34; Output: 701 Constraints:\n 1 \u0026lt;= columnTitle.length \u0026lt;= 7 columnTitle consists only of uppercase English letters. columnTitle is in the range [\u0026quot;A\u0026quot;, \u0026quot;FXSHRXW\u0026quot;].  2 Solution #  class Solution { public:  int titleToNumber(string columnTitle) {  // Time complexity: O(N), N is the size of columnTitle  // Space complexity: O(1)  int size = columnTitle.size();  long result = 0;  for(int i = 0; i \u0026lt; size; i++){  result = result * 26 + columnTitle[i] - \u0026#39;A\u0026#39; + 1;  }  return result;  } }; "},{"id":36,"href":"/docs/100/190_reverse_bits/","title":"190. Reverse Bits","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/reverse-bits/\nReverse bits of a given 32 bits unsigned integer.\nNote:\n Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer\u0026rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.  Example 1:\nInput: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2:\nInput: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints:\n The input must be a binary string of length 32  Follow up: If this function is called many times, how would you optimize it?\n2 Solution #  #include \u0026lt;bitset\u0026gt;#include \u0026lt;sstream\u0026gt;class Solution { public:  uint32_t reverseBits(uint32_t n) { \tstd::string bin_str = std::bitset\u0026lt;32\u0026gt;(n).to_string(); \tstd::stringstream ss; \tfor(int i = bin_str.size() -1 ; i \u0026gt;= 0; i--){ \tss \u0026lt;\u0026lt; bin_str[i]; \t} \tstd::bitset\u0026lt;32\u0026gt; result{ss.str()}; \treturn result.to_ulong();  } }; "},{"id":37,"href":"/docs/100/191_number_of_1_bits/","title":"191. Number of 1 Bits","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/number-of-1-bits/\nWrite a function that takes an unsigned integer and returns the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight).\nNote:\n Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer\u0026rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.  Example 1:\nInput: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three \u0026#39;1\u0026#39; bits. Example 2:\nInput: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one \u0026#39;1\u0026#39; bit. Example 3:\nInput: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one \u0026#39;1\u0026#39; bits. Constraints:\n The input must be a binary string of length 32.  Follow up: If this function is called many times, how would you optimize it?\n2 Solution #  #include \u0026lt;bitset\u0026gt;class Solution { public:  int hammingWeight(uint32_t n) { \t// Space complexity: O(32) =\u0026gt; O(1) \t// Time complexity: O(1) \tstd::bitset\u0026lt;32\u0026gt; binary = std::bitset\u0026lt;32\u0026gt;(n); \treturn binary.count();  } }; "},{"id":38,"href":"/docs/200/","title":"200th","section":"Docs","content":"1 Leetcode 200-299 #  "},{"id":39,"href":"/docs/200/201_bitwise_and_of_numbers_range/","title":"201. Bitwise AND of Numbers Range","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/bitwise-and-of-numbers-range/\nGiven two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: left = 5, right = 7 Output: 4 Example 2:\nInput: left = 0, right = 0 Output: 0 Example 3:\nInput: left = 1, right = 2147483647 Output: 0 Constraints:\n 0 \u0026lt;= left \u0026lt;= right \u0026lt;= 2^31 - 1  2 Solution #    #include \u0026lt;limits\u0026gt;class Solution { public:  int rangeBitwiseAnd(int left, int right) {  // Time complexity: O(32) =\u0026gt; O(1)  // Space complexity: O(1)  if(left == 0){  return 0;  }   int diff_bit_count = 0;  while(left != right){  left = left \u0026gt;\u0026gt; 1;  right = right \u0026gt;\u0026gt; 1;  diff_bit_count++;  }   return right \u0026lt;\u0026lt; diff_bit_count;  } }; "},{"id":40,"href":"/docs/200/203_remove_linked_list_elements/","title":"203. Remove Linked List Elements","section":"200th","content":"1 Description #  Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\nExample 1:\n Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example 2:\nInput: head = [], val = 1 Output: [] Example 3:\nInput: head = [7,7,7,7], val = 7 Output: [] Constraints:\n The number of nodes in the list is in the range [0, 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 50  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* removeElements(ListNode* head, int val) {  // Time complexity: O(N), N is the size of linked list  // Space complexity: O(1)  if(!head){  return head;  }   ListNode* prev = nullptr;  ListNode* result = nullptr;  while(head){  if(head-\u0026gt;val == val){ \tif(prev){ \tprev-\u0026gt;next = head-\u0026gt;next; \thead = head-\u0026gt;next; \t}else{ \tListNode* next = head-\u0026gt;next; \thead-\u0026gt;next = nullptr; \thead = next; \t}  }else{ \tprev = head; \thead = head-\u0026gt;next;  }   result = (result ==nullptr? prev: result);  }   return result;  } }; "},{"id":41,"href":"/docs/200/216_combination_sum_iii/","title":"216. Combination Sum III","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/combination-sum-iii/\nFind all valid combinations of k numbers that sum up to n such that the following conditions are true:\nOnly numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExample 1:\nInput: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2:\nInput: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3:\nInput: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 \u0026gt; 1, there are no valid combination. Constraints:\n 2 \u0026lt;= k \u0026lt;= 9 1 \u0026lt;= n \u0026lt;= 60  2 Solution #  class Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum3(int k, int n) {  // Time complexity: (10 - 1) * (10 -2) * .. * (10 -k)  // Space complexity:  // faster than 100.00% of C++ online submissions for Combination Sum III.  std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result;  std::vector\u0026lt;int\u0026gt; path;  backtrack(k, n, 1, result, path);  return result;  } private:  void backtrack(int k, int target, int start, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, std::vector\u0026lt;int\u0026gt;\u0026amp; path){  if(k \u0026lt; 0 || target \u0026lt; 0){  return;  }   if (k == 0 \u0026amp;\u0026amp; target == 0){  result.push_back(path);  }   for(int i = start; i \u0026lt; 10; i++){  path.push_back(i);  backtrack(k - 1, target - i, i + 1, result, path);  path.pop_back();  }  } }; "},{"id":42,"href":"/docs/200/229_majority_element_ii/","title":"229. Majority Element II","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/majority-element-ii/\nGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\nExample 1:\nInput: nums = [3,2,3] Output: [3] Example 2:\nInput: nums = [1] Output: [1] Example 3:\nInput: nums = [1,2] Output: [1,2] Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 5 * 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9  Follow up: Could you solve the problem in linear time and in O(1) space?\n2 Solution #  #include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  // Runtime complexity: O(n). n is the size of nums.  // Space complexity: O(n).  std::vector\u0026lt;int\u0026gt; result;  if (nums.size() == 0) {  return result;  }   std::unordered_map\u0026lt;int, int\u0026gt; occur;  int threshold = nums.size() / 3;  for (const auto \u0026amp;num : nums) {  auto iter = occur.find(num);  if (iter != occur.end()) { \titer-\u0026gt;second++;  } else { \toccur[num] = 1;  }   if (occur[num] \u0026gt; threshold) { \tresult.emplace_back(num); \t// since num has been added into result, just making it impossible to be \t// added twice. \toccur[num] = -0x709394;  }  }   return result;  } }; "},{"id":43,"href":"/docs/200/230_kth_smallest_element_in_a_bst/","title":"230. Kth Smallest Element in a BST","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\nGiven the root of a binary search tree, and an integer k, return the k^th smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1:\n  Input: root = [3,1,4,null,2], k = 1 Output: 1 Example 2:\n  Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 Constraints:\nThe number of nodes in the tree is n.\n 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= Node.val \u0026lt;= 10^4  Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\n2 Solution #  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public:  int kthSmallest(TreeNode* root, int k) { \t// Time complexity: O(N) \t// Space compleixty: O(1) \tpreorder(root,k ); \treturn kth_value;  }   void preorder(TreeNode* root, int k){ \tif(!root){ \tif(-1 == kth){ \tkth = 0; \t} \treturn; \t}else{ \tpreorder(root-\u0026gt;left, k); \tkth ++; \tif (kth == k){ \tkth_value = root-\u0026gt;val; \t} \tpreorder(root-\u0026gt;right,k ); \treturn;  \t}  } int kth_value = -1; int kth = -1; }; "},{"id":44,"href":"/docs/200/231_power_of_two/","title":"231. Power of Two","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/power-of-two/\nGiven an integer n, return true if it is a power of two. Otherwise, return false.\nAn integer n is a power of two, if there exists an integer x such that n == 2^x.\nExample 1:\nInput: n = 1 Output: true Explanation: 20 = 1 Example 2:\nInput: n = 16 Output: true Explanation: 24 = 16 Example 3:\nInput: n = 3 Output: false Constraints:\n -2^31 \u0026lt;= n \u0026lt;= 2^31 - 1  Follow up: Could you solve it without loops/recursion?\n2 Solution #  #include \u0026lt;bitset\u0026gt;class Solution { public:  bool isPowerOfTwo(int n) {  // Space complexity: O(33) =\u0026gt; O(1)  // Time complexity: O(1)  return std::bitset\u0026lt;33\u0026gt;(n).count() == 1;  } }; "},{"id":45,"href":"/docs/200/235_lowest_common_ancestor_of_a_binary_search_tree/","title":"235. Lowest Common Ancestor of a Binary Search Tree","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\n  Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2:\n  Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [2,1], p = 2, q = 1 Output: 2 Constraints:\n The number of nodes in the tree is in the range [2, 10^5]. -10^9 \u0026lt;= Node.val \u0026lt;= 10^9 All Node.val are unique. p != q p and q will exist in the BST.  2 Solution #  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */  class Solution { public:  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { \t// Time complexity: O(LogN) \t// Space complexity: O(1) \twhile(root){ \tif(root-\u0026gt;val \u0026gt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val\u0026gt; q-\u0026gt;val){ \troot = root-\u0026gt;left; \t}else if(root-\u0026gt;val \u0026lt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt; q-\u0026gt;val) { \troot = root-\u0026gt;right; \t}else{ \treturn root; \t} \t} \treturn root;  }  }; "},{"id":46,"href":"/docs/200/236_lowest_common_ancestor_of_a_binary_tree/","title":"236. Lowest Common Ancestor of a Binary Tree","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\n Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2:\n  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [1,2], p = 1, q = 2 Output: 1 Constraints:\n The number of nodes in the tree is in the range [2, 10^5]. -10^9 \u0026lt;= Node.val \u0026lt;= 10^9 All Node.val are unique. p != q p and q will exist in the tree.  2 Solution #  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public:  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { \t// Space complexity: O(1) \t// Time complexity: O(N) \tfind(root, p, q); \treturn ancestor_;  }   bool find(TreeNode* root, TreeNode* p, TreeNode* q){ \tif(!root){ \treturn false; \t}  \tint left = find(root-\u0026gt;left, p, q)? 1: 0; \tint right = find(root-\u0026gt;right, p, q)?1: 0; \tint mid = (root-\u0026gt;val == p-\u0026gt;val || root-\u0026gt;val == q-\u0026gt;val)? 1: 0; \tif(left + right + mid \u0026gt;= 2){ \tancestor_ = root; \t}  \treturn (left + right + mid) \u0026gt; 0;  } private:  TreeNode* ancestor_ = nullptr; }; "},{"id":47,"href":"/docs/200/260_single_number_iii/","title":"260. Single Number III","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/single-number-iii/ Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\nExample 1:\nInput: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer. Example 2:\nInput: nums = [-1,0] Output: [-1,0] Example 3:  Input: nums = [0,1] Output: [1,0] Constraints:\n 2 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -2^31 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1 Each integer in nums will appear twice, only two integers will appear once.  2 Solution #    #include \u0026lt;numeric\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;functional\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  // Time complexity: O(2N) =\u0026gt; O(N)  // Space complexity: O(1)  int diff = std::accumulate(nums.begin(), nums.end(), 0, std::bit_xor\u0026lt;\u0026gt;{});  // find the last set bit  // corner case  if(diff == std::numeric_limits\u0026lt;int\u0026gt;::min()){  diff = 0;  }else{  diff \u0026amp;= (~diff + 1);  }   std::vector\u0026lt;int\u0026gt; result{0, 0};  for(const auto\u0026amp; num: nums){  if(diff\u0026amp;num){ \tresult[0]^= num;  }else{ \tresult[1]^=num;  }  }  return result;  } }; "},{"id":48,"href":"/docs/200/268_missing_number/","title":"268. Missing Number","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/missing-number/\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nInput: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2:\nInput: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3:\nInput: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints:\n n == nums.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= nums[i] \u0026lt;= n All the numbers of nums are unique.  Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\n2 Solution #  #include \u0026lt;vector\u0026gt;class Solution { public:  int missingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  // Time complexity: O(n), n is the size of nums.  // Space complexity: O(1)  int n = nums.size();  int expected_sum = n * (n + 1) / 2.0;  for(const auto\u0026amp; num: nums){  expected_sum -= num;  }  return expected_sum;  } }; "},{"id":49,"href":"/docs/200/278_first_bad_version/","title":"278. First Bad Version","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/first-bad-version/\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nExample 1:\nInput: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -\u0026gt; false call isBadVersion(5) -\u0026gt; true call isBadVersion(4) -\u0026gt; true Then 4 is the first bad version. Example 2:\nInput: n = 1, bad = 1 Output: 1 Constraints:\n 1 \u0026lt;= bad \u0026lt;= n \u0026lt;= 2 ^ 31 - 1  2 Solution #  // The API isBadVersion is defined for you. // bool isBadVersion(int version);  class Solution { public:  int firstBadVersion(int n) { \t// it\u0026#39;s similar with `git bisect` command \t// time complexity: O(log N) \t// space complexity: O(1) \tint high = n; \tint low = 1; \tint first = 0; \twhile(low \u0026lt;= high){ \tint mid = low + (high - low) / 2; \tbool bad = isBadVersion(mid); \tif(bad){ \tfirst = mid; \thigh = mid - 1; \t}else{ \tlow = mid + 1; \t} \t}  \treturn first;  } }; "},{"id":50,"href":"/docs/200/287_find_the_duplicate_number/","title":"287. Find the Duplicate Number","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/find-the-duplicate-number/\nGiven an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and uses only constant extra space.\nExample 1:\nInput: nums = [1,3,4,2,2] Output: 2 Example 2:\nInput: nums = [3,1,3,4,2] Output: 3 Constraints:\n 1 \u0026lt;= n \u0026lt;= 105 nums.length == n + 1 1 \u0026lt;= nums[i] \u0026lt;= n All the integers in nums appear only once except for precisely one integer which appears two or more times.  Follow up:\n How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity?  2 Solution #  class Solution { public:  int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums){  // Since each integer is in the range [1, n] inclusive, then just map the number to index  // Time complexity: O(n)  // Space complexity: O(1)  while(nums[0] != nums[nums[0]]){  std::swap(nums[0], nums[nums[0]]);  }  return nums[0];  } }; "},{"id":51,"href":"/docs/200/297_serialize_and_deserialize_binary_tree/","title":"297. Serialize and Deserialize Binary Tree","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nExample 1:\n  Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2:\nInput: root = [] Output: [] Constraints:\n The number of nodes in the tree is in the range [0, 10^4]. -1000 \u0026lt;= Node.val \u0026lt;= 1000  2 Solution #  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include \u0026lt;cstdlib\u0026gt;#include \u0026lt;sstream\u0026gt;class Codec { public:   // Encodes a tree to a single string.  string serialize(TreeNode* root) { \t// time complexity: O(N), N is the node number of tree. \t// space complexity: O(N) \tstd::stringstream ss; \tdfs_serialize(root, ss); \treturn ss.str();   }   void dfs_serialize(TreeNode* root, std::stringstream\u0026amp; ss){ \t// pre-order \tif(root){ \tss \u0026lt;\u0026lt; std::to_string(root-\u0026gt;val) \u0026lt;\u0026lt; \u0026#34;|\u0026#34;; \tdfs_serialize(root-\u0026gt;left, ss); \tdfs_serialize(root-\u0026gt;right, ss); \t}else{ \t// represent null as * \tss \u0026lt;\u0026lt; \u0026#34;*|\u0026#34;; \t}  }    // Decodes your encoded data to tree.  TreeNode* deserialize(string data) { \t// time complexity: O(N) \t// space complexity: O(N) \tint index = 0; \treturn dfs_deserialize(data, index);  }    TreeNode* dfs_deserialize(const string\u0026amp; data, int\u0026amp; index) { \tif(index \u0026gt;= data.size()){ \treturn nullptr; \t}  \tint start = index; \twhile(data[index] != \u0026#39;|\u0026#39;){ \tindex++; \t}  \tstd::string token = data.substr(start, index - start);  \tif(token == \u0026#34;*\u0026#34;){ \treturn nullptr; \t}  \tTreeNode *node = new TreeNode(std::atoi(token.c_str())); \t// data[index] = \u0026#34;|\u0026#34; \tindex++; \tnode-\u0026gt;left = dfs_deserialize(data, index);  \tindex++; \tnode-\u0026gt;right = dfs_deserialize(data, index);  \treturn node;   } };  // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root)); "},{"id":52,"href":"/docs/300/","title":"300th","section":"Docs","content":"1 Leetcode 300-399 #  "},{"id":53,"href":"/docs/300/328_odd_even_linked_list/","title":"328. Odd Even Linked List","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/odd-even-linked-list/ Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExample 1: Input: head = [1,2,3,4,5] Output: [1,3,5,2,4] Example 2: Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] Constraints:\n n == number of nodes in the linked list 0 \u0026lt;= n \u0026lt;= 10^4 -10^6 \u0026lt;= Node.val \u0026lt;= 10^6  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* oddEvenList(ListNode* head) {  // Time complexity: O(N) N is the size of linked list  // Space complexity: O(1)  if(!head){  return head;  }   ListNode* first_even = nullptr;  ListNode* first_odd = nullptr;  ListNode* last_even = nullptr;  ListNode* last_odd = nullptr;  int index = 1;   while(head){  if(index % 2 == 1){ \tfirst_odd = (first_odd ==nullptr? head: first_odd);  \tif(!last_odd){ \tlast_odd = head; \t}else{ \tlast_odd -\u0026gt; next = head; \tlast_odd = last_odd-\u0026gt;next; \t}  } else{ \tfirst_even = (first_even == nullptr? head: first_even);  \tif(!last_even){ \tlast_even = head; \t}else{ \tlast_even -\u0026gt; next = head; \tlast_even = last_even-\u0026gt;next; \t}  }   head = head-\u0026gt; next;  index ++;  }   if(last_even){  last_even -\u0026gt; next = nullptr;  }   if(last_odd){  last_odd -\u0026gt; next = first_even;  }   return first_odd;  } }; "},{"id":54,"href":"/docs/300/342_power_of_four/","title":"342. Power of Four","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/power-of-four/\nGiven an integer n, return true if it is a power of four. Otherwise, return false.\nAn integer n is a power of four, if there exists an integer x such that n == 4^x.\nExample 1:\nInput: n = 16 Output: true Example 2:\nInput: n = 5 Output: false Example 3:\nInput: n = 1 Output: true Constraints:\n-2^31 \u0026lt;= n \u0026lt;= 2^31 - 1\nFollow up: Could you solve it without loops/recursion?\n2 Solution #  #include \u0026lt;bitset\u0026gt;class Solution { public:  bool isPowerOfFour(int n) {  // Space complexity: O(33) -\u0026gt; O(1)  // Time complexity: O(33) -\u0026gt; O(1)  std::bitset\u0026lt;33\u0026gt; binary = std::bitset\u0026lt;33\u0026gt;(n);  if (binary.count() != 1) {  return false;  }   std::string bin_str = binary.to_string();  for (int i = bin_str.size() - 1; i \u0026gt;= 0; i--) {  if (bin_str[i] == \u0026#39;1\u0026#39;) { \treturn (bin_str.size() - 1 - i) % 2 == 0;  }  }   return false;  } }; "},{"id":55,"href":"/docs/300/374_guess_number_higher_or_lower/","title":"374. Guess Number Higher or Lower","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/guess-number-higher-or-lower/\nWe are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\nYou call a pre-defined API int guess(int num), which returns three possible results:\n -1: Your guess is higher than the number I picked (i.e. num \u0026gt; pick). 1: Your guess is lower than the number I picked (i.e. num \u0026lt; pick). 0: your guess is equal to the number I picked (i.e. num == pick).  Return the number that I picked.\nExample 1:\nInput: n = 10, pick = 6 Output: 6 Example 2:\nInput: n = 1, pick = 1 Output: 1 Example 3:\nInput: n = 2, pick = 1 Output: 1 Constraints:\n 1 \u0026lt;= n \u0026lt;= 2^31 - 1 1 \u0026lt;= pick \u0026lt;= n  2 Solution #  /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is higher than the picked number *\t1 if num is lower than the picked number * otherwise return 0 * int guess(int num); */  class Solution { public:  int guessNumber(int n) {  // Time complexity: O(logN)  // Space complexity: O(1)  int low = 1;  int high = n;  int mid = 0;  while(low \u0026lt;= high){  mid = low + (high - low)/2;  int is_lower = guess(mid);  if(is_lower \u0026gt; 0){ \tlow = mid + 1;  }else if(is_lower \u0026lt; 0){ \thigh = mid - 1;  }else{ \treturn mid;  }  }   return mid;  } }; "},{"id":56,"href":"/docs/300/378_kth_smallest_element_in_a_sorted_matrix/","title":"378. Kth Smallest Element in a Sorted Matrix","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\nGiven an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^th smallest element in the matrix.\nNote that it is the k^th smallest element in the sorted order, not the k^th distinct element.\nYou must find a solution with a memory complexity better than O(n^2).\nExample 1:\nInput: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output: 13 Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 Example 2:\nInput: matrix = [[-5]], k = 1 Output: -5 Constraints:\n n == matrix.length == matrix[i].length 1 \u0026lt;= n \u0026lt;= 300 -10^9 \u0026lt;= matrix[i][j] \u0026lt;= 10^9 All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. 1 \u0026lt;= k \u0026lt;= n^2  Follow up:\n Could you solve the problem with a constant memory (i.e., O(1) memory complexity)? Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.  2 Solution #  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;class Solution { public:  int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;matrix, int k) {  // Time complexity: O(m * n * LogK)  // Space complexity: O(k)  std::vector\u0026lt;int\u0026gt; result;  std::make_heap(result.begin(), result.end());  int size = matrix.size();  for (int i = 0; i \u0026lt; size; i++) {  for (int j = 0; j \u0026lt; size; j++) { \tresult.push_back(matrix[i][j]); \tstd::push_heap(result.begin(), result.end()); \tif (result.size() \u0026gt; k) { \tstd::pop_heap(result.begin(), result.end()); \tresult.pop_back(); \t}  }  }   std::pop_heap(result.begin(), result.end());  return result.back();  } }; "},{"id":57,"href":"/docs/300/383_ransom_note/","title":"383. Ransom Note","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/ransom-note/\nGiven two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nInput: ransomNote = \u0026#34;a\u0026#34;, magazine = \u0026#34;b\u0026#34; Output: false Example 2:\nInput: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;ab\u0026#34; Output: false Example 3:\nInput: ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;aab\u0026#34; Output: true Constraints:\n 1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 10^5 ransomNote and magazine consist of lowercase English letters.  2 Solution #  #include \u0026lt;unordered_map\u0026gt;class Solution { public:  bool canConstruct(string ransomNote, string magazine) {  // Time complexity: O(N + M), N is the size of ransomNode, M is the size of  // magazine Space complexity: O(26) =\u0026gt; O(1)   // table doubling is expensive,so just preallocating the space  std::unordered_map\u0026lt;char, int\u0026gt; word_freq(26);   for (int i = 0; i \u0026lt; magazine.size(); i++) {  auto iter = word_freq.find(magazine[i]);  if (iter == word_freq.end()) { \tword_freq[magazine[i]] = 1;  } else { \titer-\u0026gt;second++;  }  }   for (int i = 0; i \u0026lt; ransomNote.size(); i++) {  auto iter = word_freq.find(ransomNote[i]);  if (iter == word_freq.end() || iter-\u0026gt;second \u0026lt; 1) { \treturn false;  } else { \titer-\u0026gt;second--;  }  }   return true;  } }; "},{"id":58,"href":"/docs/300/386_lexicographical_numbers/","title":"386. Lexicographical Numbers","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/lexicographical-numbers/\nGiven an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in O(n) time and uses O(1) extra space.\nExample 1:\nInput: n = 13 Output: [1,10,11,12,13,2,3,4,5,6,7,8,9] Example 2:\nInput: n = 2 Output: [1,2] Constraints:\n 1 \u0026lt;= n \u0026lt;= 5 * 10^4  2 Solution #  #include \u0026lt;vector\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; lexicalOrder(int n) {  // Time complexity: O(N)  // space complexity: O(1)  int upper = std::min(9, n);  std::vector\u0026lt;int\u0026gt; result;   for (int i = 1; i \u0026lt;= upper; i++) {  dfs(i, n, result);  }  return result;  }   void dfs(int val, int n, std::vector\u0026lt;int\u0026gt; \u0026amp;result) {  if (val \u0026lt;= n) {  result.push_back(val);  for (int i = 0; i \u0026lt;= 9; i++) { \tif (val * 10 + i \u0026lt;= n) { \tdfs(val * 10 + i, n, result); \t}  }  }  } }; "},{"id":59,"href":"/docs/400/","title":"400th","section":"Docs","content":"1 Leetcode 400-499 #  "},{"id":60,"href":"/docs/400/405_convert_a_number_to_hexadecimal/","title":"405. Convert a Number to Hexadecimal","section":"400th","content":"1 Description #  source: https://leetcode.com/problems/convert-a-number-to-hexadecimal/\nGiven an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\nNote: You are not allowed to use any built-in library method to directly solve this problem.\nExample 1:\nInput: num = 26 Output: \u0026#34;1a\u0026#34; Example 2:\nInput: num = -1 Output: \u0026#34;ffffffff\u0026#34; Constraints:\n -2^31 \u0026lt;= num \u0026lt;= 2^31 - 1  2 Solution #  #include \u0026lt;vector\u0026gt;class Solution { public:  string toHex(int num) {  // Space complexity: O(1)  // Time complexity: O(N/4) =\u0026gt; O(N)  static std::vector\u0026lt;std::string\u0026gt; hexmap{\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \t\u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \t\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;};   if (num == 0) {  return \u0026#34;0\u0026#34;;  }   uint32_t n = num;  std::string result;  while (n != 0) {  result = hexmap[n \u0026amp; 15] + result;  n = n \u0026gt;\u0026gt; 4;  }   return result;  } }; "},{"id":61,"href":"/docs/400/434_number_of_segments_in_a_string/","title":"434. Number of Segments in a String","section":"400th","content":"1 Description #  source: https://leetcode.com/problems/number-of-segments-in-a-string/\nGiven a string s, return the number of segments in the string.\nA segment is defined to be a contiguous sequence of non-space characters.\nExample 1:\nInput: s = \u0026#34;Hello, my name is John\u0026#34; Output: 5 Explanation: The five segments are [\u0026#34;Hello,\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;John\u0026#34;] Example 2:\nInput: s = \u0026#34;Hello\u0026#34; Output: 1 Constraints:\n 0 \u0026lt;= s.length \u0026lt;= 300 s consists of lowercase and uppercase English letters, digits, or one of the following characters \u0026quot;!@#$%^\u0026amp;*()_+-=',.:\u0026quot;. The only space character in s is ' '.  2 Solution #  "},{"id":62,"href":"/docs/400/449_serialize_and_deserialize_bst/","title":"449. Serialize and Deserialize BST","section":"400th","content":"1 Description #  source: https://leetcode.com/problems/serialize-and-deserialize-bst/\nSerialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\nThe encoded string should be as compact as possible.\nExample 1:\nInput: root = [2,1,3] Output: [2,1,3] Example 2:\nInput: root = [] Output: [] Constraints:\n The number of nodes in the tree is in the range [0, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 10^4 The input tree is guaranteed to be a binary search tree.  2 Solution #  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include \u0026lt;cstdlib\u0026gt;#include \u0026lt;sstream\u0026gt;class Codec { public:   // Encodes a tree to a single string.  string serialize(TreeNode* root) { \t// time complexity: O(N), N is the node number of tree. \t// space complexity: O(N) \tstd::stringstream ss; \tdfs_serialize(root, ss); \treturn ss.str();   }   void dfs_serialize(TreeNode* root, std::stringstream\u0026amp; ss){ \t// pre-order \tif(root){ \tss \u0026lt;\u0026lt; std::to_string(root-\u0026gt;val) \u0026lt;\u0026lt; \u0026#34;|\u0026#34;; \tdfs_serialize(root-\u0026gt;left, ss); \tdfs_serialize(root-\u0026gt;right, ss); \t}else{ \t// represent null as * \tss \u0026lt;\u0026lt; \u0026#34;*|\u0026#34;; \t}  }    // Decodes your encoded data to tree.  TreeNode* deserialize(string data) { \t// time complexity: O(N) \t// space complexity: O(N) \tint index = 0; \treturn dfs_deserialize(data, index);  }    TreeNode* dfs_deserialize(const string\u0026amp; data, int\u0026amp; index) { \tif(index \u0026gt;= data.size()){ \treturn nullptr; \t}  \tint start = index; \twhile(data[index] != \u0026#39;|\u0026#39;){ \tindex++; \t}  \tstd::string token = data.substr(start, index - start);  \tif(token == \u0026#34;*\u0026#34;){ \treturn nullptr; \t}  \tTreeNode *node = new TreeNode(std::atoi(token.c_str())); \t// data[index] = \u0026#34;|\u0026#34; \tindex++; \tnode-\u0026gt;left = dfs_deserialize(data, index);  \tindex++; \tnode-\u0026gt;right = dfs_deserialize(data, index);  \treturn node;   } };  // Your Codec object will be instantiated and called as such: // Codec* ser = new Codec(); // Codec* deser = new Codec(); // string tree = ser-\u0026gt;serialize(root); // TreeNode* ans = deser-\u0026gt;deserialize(tree); // return ans; "},{"id":63,"href":"/docs/600/","title":"600th","section":"Docs","content":"1 Leetcode 600-699 #  "},{"id":64,"href":"/docs/600/692_top_k_frequent_words/","title":"692. Top K Frequent Words","section":"600th","content":"1 Description #  source: https://leetcode.com/problems/top-k-frequent-words/\nGiven an array of strings words and an integer k, return the k most frequent strings.\nReturn the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.\nExample 1:\nInput: words = [\u0026#34;i\u0026#34;,\u0026#34;love\u0026#34;,\u0026#34;leetcode\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;love\u0026#34;,\u0026#34;coding\u0026#34;], k = 2 Output: [\u0026#34;i\u0026#34;,\u0026#34;love\u0026#34;] Explanation: \u0026#34;i\u0026#34; and \u0026#34;love\u0026#34; are the two most frequent words. Note that \u0026#34;i\u0026#34; comes before \u0026#34;love\u0026#34; due to a lower alphabetical order. Example 2:\nInput: words = [\u0026#34;the\u0026#34;,\u0026#34;day\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;sunny\u0026#34;,\u0026#34;the\u0026#34;,\u0026#34;the\u0026#34;,\u0026#34;the\u0026#34;,\u0026#34;sunny\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;is\u0026#34;], k = 4 Output: [\u0026#34;the\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;sunny\u0026#34;,\u0026#34;day\u0026#34;] Explanation: \u0026#34;the\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;sunny\u0026#34; and \u0026#34;day\u0026#34; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. Constraints:\n 1 \u0026lt;= words.length \u0026lt;= 500 1 \u0026lt;= words[i] \u0026lt;= 10 words[i] consists of lowercase English letters. k is in the range [1, The number of unique words[i]]  Follow-up: Could you solve it in O(n log(k)) time and O(n) extra space?\n2 Solution #  #include \u0026lt;utility\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;class Solution { public:  vector\u0026lt;string\u0026gt; topKFrequent(vector\u0026lt;string\u0026gt;\u0026amp; words, int k) {  // Space complexity: O(M), N is the size of unique words  // Time complexity: O(N + N*LogN) =\u0026gt; O(N*LogN), N is the size of words.  std::unordered_map\u0026lt;std::string, int\u0026gt; frequency;  for(const auto\u0026amp; word: words){  auto iter = frequency.find(word);  if(iter == frequency.end()){ \tfrequency[word] = 1;  }else{ \titer-\u0026gt;second += 1;  }  }   auto cmp = [](const std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; a, const std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; b){  if(a.second == b.second){ \treturn a.first \u0026gt; b.first;  }else{ \treturn a.second \u0026lt; b.second;  }   };  std::vector\u0026lt;std::pair\u0026lt;std::string, int\u0026gt;\u0026gt; heap;  heap.reserve(frequency.size());  for(auto iter = frequency.begin(); iter != frequency.end(); iter ++){  heap.push_back(*iter);  std::push_heap(heap.begin(), heap.end(), cmp);  }   std::vector\u0026lt;std::string\u0026gt; result;  while(k \u0026gt; 0 \u0026amp;\u0026amp; heap.size() \u0026gt; 0){  std::pop_heap(heap.begin(), heap.end(), cmp);  result.push_back(heap.back().first);  heap.pop_back();  k--;  }   return result;  } }; "},{"id":65,"href":"/docs/1700/","title":"1700th","section":"Docs","content":"1 Leetcode 1700-1799 #  "},{"id":66,"href":"/docs/1700/1721_swapping_nodes_in_a_linked_list/","title":"1721. Swapping Nodes in a Linked List","section":"1700th","content":"1 Description #  source: https://leetcode.com/problems/swapping-nodes-in-a-linked-list/\nYou are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Constraints:\n The number of nodes in the list is n. 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapNodes(ListNode* head, int k) {  // time complexity: O(2N) = O(N), N = size of linked list  // space compleixty(1)  int size = 0;  ListNode* first = head;  ListNode* kth_from_begin = nullptr;  ListNode* kth_from_end = nullptr;  while(first){  size++;  if(size == k){ \tkth_from_begin = first;  }   first = first-\u0026gt;next;  }    int next_round_size = 0;  first = head;  while(first){  next_round_size++;    if(next_round_size == size - k + 1){ \tkth_from_end = first; \tbreak;  }  first = first-\u0026gt;next;  }   int tmp = kth_from_begin -\u0026gt; val;  kth_from_begin-\u0026gt;val = kth_from_end-\u0026gt;val;  kth_from_end -\u0026gt; val = tmp;   return head;  } }; "},{"id":67,"href":"/docs/2000/","title":"2000th","section":"Docs","content":"1 Leetcode 2000-2099 #  "},{"id":68,"href":"/docs/2000/2095_delete_the_middle_node_of_a_linked_list/","title":"2095. Delete the Middle Node of a Linked List","section":"2000th","content":"1 Description #  source: https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/\nYou are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\nThe middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.\nFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\nExample 1:\n Input: head = [1,3,4,7,1,2,6] Output: [1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. Example 2:\n Input: head = [1,2,3,4] Output: [1,2,4] Explanation: The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. Example 3:\n Input: head = [2,1] Output: [2] Explanation: The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. Constraints:\n The number of nodes in the list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteMiddle(ListNode* head) { \t// Time complexity: O(1.5N) = O(N). N is the size of linked list \t// Space complexity: O(1) \tif(!head){ \treturn head; \t}  \tint size = 0; \tListNode* first = head; \twhile(first){ \tsize++; \tfirst = first-\u0026gt;next; \t}  \tif(1 == size){ \treturn nullptr; \t}  \tint middle = size / 2; \tint index = 0; \tfirst = head; \twhile(first){ \tif(index == middle - 1){ \t// the prev node of middle node \tfirst-\u0026gt;next = first-\u0026gt;next-\u0026gt;next; \tbreak; \t}  \tindex ++; \tfirst = first-\u0026gt;next; \t}  \treturn head;  } }; "}]