[{"id":0,"href":"/leetcode_book/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { // time complexity: O(n)  // space complexity: O(1)  if (k == 0 || !head){ return head; } int size = 0; ListNode* first = head; ListNode* last_node = head; while(first){ if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ last_node = first; } first = first -\u0026gt; next; size ++; } // it will be the same linked_list after rotate `size` steps  k = k % size; if(k ==0){ return head; } // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head; for(int i = 0; i \u0026lt; size - k - 1; i++){ k_minus_1 = k_minus_1 -\u0026gt;next; } ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr; last_node -\u0026gt; next = head; return k_node; } }; "},{"id":1,"href":"/leetcode_book/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: seen = set() while head: if head in seen: return True seen.add(head) head = head.next return False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){ return false; } ListNode* fast = head -\u0026gt; next; while(head){ // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ return true; } if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; } else{ // if there is a cycle, the fast-\u0026gt; next will never be null \treturn false; } head = head-\u0026gt;next; } return false; } }; "},{"id":2,"href":"/leetcode_book/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":3,"href":"/leetcode_book/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "}]