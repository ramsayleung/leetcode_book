[{"id":0,"href":"/docs/000/2_add_two_numbers/","title":"2. Add two number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807. 2 Solution #  Solution in Python3:\n# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # Runtime: 72 ms, faster than 62.00% of Python3 online submissions for Add Two Numbers. # time complexity: O(n1+n2), n1 is the length of l1, n2 is the length of l2 # space complexity: O(max(n1,n2)), the length of sum of two number equals the larger\u0026#39;s class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: num1 = self.getNumber(l1) num2 = self.getNumber(l2) result = num1+num2 return self.constructNumber(result) def getNumber(self, llist: ListNode) -\u0026gt; int: num = \u0026#34;\u0026#34; while llist: num = str(llist.val) + num llist = llist.next return int(num) def constructNumber(self, num: int) -\u0026gt; ListNode: print(num) input = str(num) parent = root = None while len(input) \u0026gt; 0: val = input[len(input)-1] newNode = ListNode(int(val)) if not parent: parent = newNode root = parent else: parent.next = newNode parent = newNode input = input[:len(input)-1] return root Solution in C++:\n  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { // Runtime complexity O(n), n = max(l1.size(), l2.size())  // Space complexity O(1)  ListNode *result = l1; ListNode *prev = nullptr; int carry = 0; while (l1 \u0026amp;\u0026amp; l2) { int add_result = l1-\u0026gt;val + l2-\u0026gt;val + carry; if (add_result % 10 == add_result) { l1-\u0026gt;val = add_result; carry = 0; } else { l1-\u0026gt;val = add_result % 10; carry = 1; } prev = l1; l1 = l1-\u0026gt;next; l2 = l2-\u0026gt;next; } if (l1 || l2) { prev-\u0026gt;next = (l1 != nullptr ? l1 : l2); ListNode *head = prev-\u0026gt;next; while (head) { int add_result = head-\u0026gt;val + carry; if (add_result % 10 == add_result) { head-\u0026gt;val = add_result; carry = 0; } else { head-\u0026gt;val = add_result % 10; carry = 1; } prev = head; head = head-\u0026gt;next; } } else { if (carry != 0) { prev-\u0026gt;next = new ListNode(carry); return result; } } if (carry != 0) { prev-\u0026gt;next = new ListNode(carry); } return result; } }; "},{"id":1,"href":"/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":2,"href":"/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "},{"id":3,"href":"/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { // time complexity: O(n)  // space complexity: O(1)  if (k == 0 || !head){ return head; } int size = 0; ListNode* first = head; ListNode* last_node = head; while(first){ if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ last_node = first; } first = first -\u0026gt; next; size ++; } // it will be the same linked_list after rotate `size` steps  k = k % size; if(k ==0){ return head; } // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head; for(int i = 0; i \u0026lt; size - k - 1; i++){ k_minus_1 = k_minus_1 -\u0026gt;next; } ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr; last_node -\u0026gt; next = head; return k_node; } }; "},{"id":4,"href":"/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: seen = set() while head: if head in seen: return True seen.add(head) head = head.next return False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){ return false; } ListNode* fast = head -\u0026gt; next; while(head){ // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ return true; } if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; } else{ // if there is a cycle, the fast-\u0026gt; next will never be null \treturn false; } head = head-\u0026gt;next; } return false; } }; "}]