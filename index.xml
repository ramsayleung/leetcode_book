<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Leetcode Book</title><link>https://ramsayleung.github.io/leetcode_book/</link><description>Recent content in Introduction on Leetcode Book</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ramsayleung.github.io/leetcode_book/index.xml" rel="self" type="application/rss+xml"/><item><title>2. Add two number</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/2_add_two_numbers/</link><pubDate>Fri, 24 Apr 2020 21:45:43 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/2_add_two_numbers/</guid><description>1 Description # source: https://leetcode.com/problems/add-two-numbers/
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description></item><item><title>12. Integer to Roman</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/12_integer_to_roman/</link><pubDate>Sun, 10 Apr 2022 15:12:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/12_integer_to_roman/</guid><description>1 Description # source: https://leetcode.com/problems/integer-to-roman/
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/24_swap_nodes_in_pairs/</link><pubDate>Tue, 22 Mar 2022 09:03:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/24_swap_nodes_in_pairs/</guid><description>1 Description # Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)
Example 1:
Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:
Input: head = [] Output: [] Example 3:
Input: head = [1] Output: [1] Constraints:
The number of nodes in the list is in the range [0, 100].</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/26_remove_duplicates_from_sorted_array/</link><pubDate>Sat, 19 Mar 2022 09:02:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/26_remove_duplicates_from_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/remove-duplicates-from-sorted-array/
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/33_search_in_rotated_sorted_array/</link><pubDate>Sat, 16 Apr 2022 08:57:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/33_search_in_rotated_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/search-in-rotated-sorted-array/
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 27 Apr 2020 16:05:11 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] 2 Solution # # Runtime: 80 ms, faster than 95.</description></item><item><title>35. Search Insert Position</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/35.search_insert_position/</link><pubDate>Wed, 02 Feb 2022 20:34:17 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/35.search_insert_position/</guid><description>1 Description # source: https://leetcode.com/problems/search-insert-position/
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2:
Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3:</description></item><item><title>43. Multiply String</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/43.multiply_strings/</link><pubDate>Tue, 01 Mar 2022 19:27:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/43.multiply_strings/</guid><description>1 Description # source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
Example 1:
Input: num1 = &amp;#34;2&amp;#34;, num2 = &amp;#34;3&amp;#34; Output: &amp;#34;6&amp;#34; Example 2:
Input: num1 = &amp;#34;123&amp;#34;, num2 = &amp;#34;456&amp;#34; Output: &amp;#34;56088&amp;#34; Constraints:
1 &amp;lt;= num1.</description></item><item><title>61. Rotate List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/61_rotate_list/</link><pubDate>Tue, 15 Feb 2022 22:12:26 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/61_rotate_list/</guid><description>1 Description # source: https://leetcode.com/problems/rotate-list/
Given the head of a linked list, rotate the list to the right by k places.
Example 1:
Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:
Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:
The number of nodes in the list is in the range [0, 500]. -100 &amp;lt;= Node.val &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 2 * 10^9 2 Solution # /** * Definition for singly-linked list.</description></item><item><title>67. Add Binary</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/67_add_binary/</link><pubDate>Tue, 01 Mar 2022 21:03:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/67_add_binary/</guid><description>1 Description # source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.
Example 1:
Input: a = &amp;#34;11&amp;#34;, b = &amp;#34;1&amp;#34; Output: &amp;#34;100&amp;#34; Example 2:
Input: a = &amp;#34;1010&amp;#34;, b = &amp;#34;1011&amp;#34; Output: &amp;#34;10101&amp;#34; Constraints:
1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.</description></item><item><title>83. Remove Duplicates from Sorted List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/83_remove_duplicates_from_sorted_list/</link><pubDate>Tue, 22 Mar 2022 23:19:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/83_remove_duplicates_from_sorted_list/</guid><description>1 Description # source: https://leetcode.com/problems/remove-duplicates-from-sorted-list/
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
Example 1:
Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:
The number of nodes in the list is in the range [0, 300]. -100 &amp;lt;= Node.val &amp;lt;= 100 The list is guaranteed to be sorted in ascending order.</description></item><item><title>86. Partition List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/86_partition_list/</link><pubDate>Thu, 24 Mar 2022 21:05:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/86_partition_list/</guid><description>1 Description # source: https://leetcode.com/problems/partition-list/
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
Example 1:
Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2:
Input: head = [2,1], x = 2 Output: [1,2] Constraints:</description></item><item><title>92. Reverse Linked List II</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/92_reverse_linked_list_ii/</link><pubDate>Wed, 23 Mar 2022 12:52:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/92_reverse_linked_list_ii/</guid><description>1 Description # source: https://leetcode.com/problems/reverse-linked-list-ii/
Given the head of a singly linked list and two integers left and right where left &amp;lt; right=, reverse the nodes of the list from position left to position right, and return the reversed list.
Example 1:
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2:
Input: head = [5], left = 1, right = 1 Output: [5] Constraints:</description></item><item><title>141. Linked list cycle</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</link><pubDate>Tue, 28 Apr 2020 09:04:58 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</guid><description>1 Description # source: https://leetcode.com/problems/linked-list-cycle/
Given a linked list, determine if it has a cycle in it.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Example 1:
Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.</description></item><item><title>143. Reorder List</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</link><pubDate>Sun, 27 Mar 2022 09:55:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</guid><description>1 Description # source: https://leetcode.com/problems/reorder-list/ You are given the head of a singly linked-list. The list can be represented as:
L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list&amp;rsquo;s nodes. Only nodes themselves may be changed.</description></item><item><title>162. Find Peak Element</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</link><pubDate>Sat, 16 Apr 2022 09:02:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</guid><description>1 Description # source: https://leetcode.com/problems/find-peak-element/
A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in O(log n) time.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description></item><item><title>190. Reverse Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</link><pubDate>Sun, 10 Apr 2022 20:45:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</guid><description>1 Description # source: https://leetcode.com/problems/reverse-bits/
Reverse bits of a given 32 bits unsigned integer.
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2&amp;rsquo;s complement notation.</description></item><item><title>191. Number of 1 Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</link><pubDate>Sun, 10 Apr 2022 20:18:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</guid><description>1 Description # source: https://leetcode.com/problems/number-of-1-bits/
Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned.</description></item><item><title>203. Remove Linked List Elements</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/203_remove_linked_list_elements/</link><pubDate>Thu, 24 Mar 2022 21:24:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/203_remove_linked_list_elements/</guid><description>1 Description # Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example 2:
Input: head = [], val = 1 Output: [] Example 3:
Input: head = [7,7,7,7], val = 7 Output: [] Constraints:
The number of nodes in the list is in the range [0, 10^4].</description></item><item><title>229. Majority Element II</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/229_majority_element_ii/</link><pubDate>Sun, 10 Apr 2022 13:07:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/229_majority_element_ii/</guid><description>1 Description # source: https://leetcode.com/problems/majority-element-ii/
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Example 1:
Input: nums = [3,2,3] Output: [3] Example 2:
Input: nums = [1] Output: [1] Example 3:
Input: nums = [1,2] Output: [1,2] Constraints:
1 &amp;lt;= nums.length &amp;lt;= 5 * 10^4 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 Follow up: Could you solve the problem in linear time and in O(1) space?</description></item><item><title>231. Power of Two</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/231_power_of_two/</link><pubDate>Sun, 10 Apr 2022 21:12:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/231_power_of_two/</guid><description>1 Description # source: https://leetcode.com/problems/power-of-two/
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2^x.
Example 1:
Input: n = 1 Output: true Explanation: 20 = 1 Example 2:
Input: n = 16 Output: true Explanation: 24 = 16 Example 3:
Input: n = 3 Output: false Constraints:</description></item><item><title>268. Missing Number</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/268_missing_number/</link><pubDate>Sun, 10 Apr 2022 14:17:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/268_missing_number/</guid><description>1 Description # source: https://leetcode.com/problems/missing-number/
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Example 1:
Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</description></item><item><title>278. First Bad Version</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/278_first_bad_version/</link><pubDate>Sat, 16 Apr 2022 21:05:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/278_first_bad_version/</guid><description>1 Description # source: https://leetcode.com/problems/first-bad-version/
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>287. Find the Duplicate Number</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/287_find_the_duplicate_number/</link><pubDate>Sat, 16 Apr 2022 08:49:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/287_find_the_duplicate_number/</guid><description>1 Description # source: https://leetcode.com/problems/find-the-duplicate-number/
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.
Example 1:
Input: nums = [1,3,4,2,2] Output: 2 Example 2:
Input: nums = [3,1,3,4,2] Output: 3 Constraints:</description></item><item><title>328. Odd Even Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/328_odd_even_linked_list/</link><pubDate>Thu, 24 Mar 2022 22:01:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/328_odd_even_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/odd-even-linked-list/ Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>342. Power of Four</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/342_power_of_four/</link><pubDate>Thu, 14 Apr 2022 22:57:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/342_power_of_four/</guid><description>1 Description # source: https://leetcode.com/problems/power-of-four/
Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4^x.
Example 1:
Input: n = 16 Output: true Example 2:
Input: n = 5 Output: false Example 3:
Input: n = 1 Output: true Constraints:
-2^31 &amp;lt;= n &amp;lt;= 2^31 - 1</description></item><item><title>374. Guess Number Higher or Lower</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/374_guess_number_higher_or_lower/</link><pubDate>Sun, 17 Apr 2022 13:09:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/374_guess_number_higher_or_lower/</guid><description>1 Description # source: https://leetcode.com/problems/guess-number-higher-or-lower/
We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns three possible results:
-1: Your guess is higher than the number I picked (i.</description></item><item><title>1721. Swapping Nodes in a Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/1700/1721_swapping_nodes_in_a_linked_list/</link><pubDate>Tue, 22 Mar 2022 21:49:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/1700/1721_swapping_nodes_in_a_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
Example 1:
Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Constraints:</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/2000/2095_delete_the_middle_node_of_a_linked_list/</link><pubDate>Sun, 27 Mar 2022 10:37:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/2000/2095_delete_the_middle_node_of_a_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/
You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.
The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.
For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.</description></item></channel></rss>