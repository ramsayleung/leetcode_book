<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Leetcode Book</title><link>https://ramsayleung.github.io/leetcode_book/</link><description>Recent content in Introduction on Leetcode Book</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ramsayleung.github.io/leetcode_book/index.xml" rel="self" type="application/rss+xml"/><item><title>2. Add two number</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/2_add_two_numbers/</link><pubDate>Fri, 24 Apr 2020 21:45:43 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/2_add_two_numbers/</guid><description>1 Description # source: https://leetcode.com/problems/add-two-numbers/
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description></item><item><title>12. Integer to Roman</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/12_integer_to_roman/</link><pubDate>Sun, 10 Apr 2022 15:12:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/12_integer_to_roman/</guid><description>1 Description # source: https://leetcode.com/problems/integer-to-roman/
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/24_swap_nodes_in_pairs/</link><pubDate>Tue, 22 Mar 2022 09:03:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/24_swap_nodes_in_pairs/</guid><description>1 Description # Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)
Example 1:
Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:
Input: head = [] Output: [] Example 3:
Input: head = [1] Output: [1] Constraints:
The number of nodes in the list is in the range [0, 100].</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/26_remove_duplicates_from_sorted_array/</link><pubDate>Sat, 19 Mar 2022 09:02:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/26_remove_duplicates_from_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/remove-duplicates-from-sorted-array/
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/33_search_in_rotated_sorted_array/</link><pubDate>Sat, 16 Apr 2022 08:57:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/33_search_in_rotated_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/search-in-rotated-sorted-array/
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/34_find_first_and_last_position_of_element_in_sorted_array/</link><pubDate>Mon, 27 Apr 2020 16:05:11 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/34_find_first_and_last_position_of_element_in_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] 2 Solution # # Runtime: 80 ms, faster than 95.</description></item><item><title>35. Search Insert Position</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/35.search_insert_position/</link><pubDate>Wed, 02 Feb 2022 20:34:17 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/35.search_insert_position/</guid><description>1 Description # source: https://leetcode.com/problems/search-insert-position/
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2:
Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3:</description></item><item><title>43. Multiply String</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/43.multiply_strings/</link><pubDate>Tue, 01 Mar 2022 19:27:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/43.multiply_strings/</guid><description>1 Description # source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
Example 1:
Input: num1 = &amp;#34;2&amp;#34;, num2 = &amp;#34;3&amp;#34; Output: &amp;#34;6&amp;#34; Example 2:
Input: num1 = &amp;#34;123&amp;#34;, num2 = &amp;#34;456&amp;#34; Output: &amp;#34;56088&amp;#34; Constraints:
1 &amp;lt;= num1.</description></item><item><title>54. Spiral Matrix</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/54_spiral_matrix/</link><pubDate>Sun, 08 May 2022 08:09:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/54_spiral_matrix/</guid><description>1 Description # source: https://leetcode.com/problems/spiral-matrix/
Given an m x n matrix, return all elements of the matrix in spiral order.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2:
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints:
m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 10 -100 &amp;lt;= matrix[i][j] &amp;lt;= 100 2 Solution # #include &amp;lt;iostream&amp;gt;class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { // Time complexity: O(m * n) // Space complexity: O(m * n) int m = matrix.</description></item><item><title>56. Merge Intervals</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/merge_intervals/</link><pubDate>Mon, 27 Apr 2020 22:55:01 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/merge_intervals/</guid><description>1 Description # source: https://leetcode.com/problems/merge-intervals/
Given a collection of intervals, merge all overlapping intervals.
Example 1:
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:
Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
2 Solution # from typing import List # time complexity: O(nlogn), time to sort intervals.</description></item><item><title>57. Insert Interval</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/57_insert_interval/</link><pubDate>Sat, 30 Apr 2022 08:36:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/57_insert_interval/</guid><description>1 Description # source: https://leetcode.com/problems/insert-interval/
You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).</description></item><item><title>59. Spiral Matrix II</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/59_spiral_matrix_ii/</link><pubDate>Sun, 08 May 2022 08:49:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/59_spiral_matrix_ii/</guid><description>1 Description # source: https://leetcode.com/problems/spiral-matrix-ii/ Given a positive integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order.
Example 1:
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Example 2:
Input: n = 1 Output: [[1]] Constraints:
1 &amp;lt;= n &amp;lt;= 20 2 Solution # class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n) { // Space complexity: O(n * n) // Time complexity: O(n * n) // faster than 100.</description></item><item><title>61. Rotate List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/61_rotate_list/</link><pubDate>Tue, 15 Feb 2022 22:12:26 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/61_rotate_list/</guid><description>1 Description # source: https://leetcode.com/problems/rotate-list/
Given the head of a linked list, rotate the list to the right by k places.
Example 1:
Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:
Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:
The number of nodes in the list is in the range [0, 500]. -100 &amp;lt;= Node.val &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 2 * 10^9 2 Solution # /** * Definition for singly-linked list.</description></item><item><title>67. Add Binary</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/67_add_binary/</link><pubDate>Tue, 01 Mar 2022 21:03:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/67_add_binary/</guid><description>1 Description # source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.
Example 1:
Input: a = &amp;#34;11&amp;#34;, b = &amp;#34;1&amp;#34; Output: &amp;#34;100&amp;#34; Example 2:
Input: a = &amp;#34;1010&amp;#34;, b = &amp;#34;1011&amp;#34; Output: &amp;#34;10101&amp;#34; Constraints:
1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.</description></item><item><title>71. Simplify Path</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/71_simplify_path/</link><pubDate>Sat, 30 Apr 2022 08:44:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/71_simplify_path/</guid><description>1 Description # source: https://leetcode.com/problems/simplify-path/
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.
In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/73_set_matrix_zeroes/</link><pubDate>Sun, 08 May 2022 20:00:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/73_set_matrix_zeroes/</guid><description>1 Description # source: https://leetcode.com/problems/set-matrix-zeroes/
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Constraints:
m == matrix.length n == matrix[0].length 1 &amp;lt;= m, n &amp;lt;= 200 -2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1 Follow up:</description></item><item><title>75. Sort Colors</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/75_sort_colors/</link><pubDate>Sat, 30 Apr 2022 08:54:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/75_sort_colors/</guid><description>1 Description # source: https://leetcode.com/problems/sort-colors/
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library&amp;rsquo;s sort function.
Example 1:</description></item><item><title>82. Remove Duplicates from Sorted List II</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/82_remove_duplicates_from_sorted_list_ii/</link><pubDate>Sat, 30 Apr 2022 08:59:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/82_remove_duplicates_from_sorted_list_ii/</guid><description>1 Description # source: https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/
Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.
Example 1:
Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2:
Input: head = [1,1,1,2,3] Output: [2,3] Constraints:
The number of nodes in the list is in the range [0, 300].</description></item><item><title>83. Remove Duplicates from Sorted List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/83_remove_duplicates_from_sorted_list/</link><pubDate>Tue, 22 Mar 2022 23:19:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/83_remove_duplicates_from_sorted_list/</guid><description>1 Description # source: https://leetcode.com/problems/remove-duplicates-from-sorted-list/
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
Example 1:
Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:
The number of nodes in the list is in the range [0, 300]. -100 &amp;lt;= Node.val &amp;lt;= 100 The list is guaranteed to be sorted in ascending order.</description></item><item><title>86. Partition List</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/86_partition_list/</link><pubDate>Thu, 24 Mar 2022 21:05:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/86_partition_list/</guid><description>1 Description # source: https://leetcode.com/problems/partition-list/
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
Example 1:
Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2:
Input: head = [2,1], x = 2 Output: [1,2] Constraints:</description></item><item><title>88. Merge Sorted Array</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/88_merge_sorted_array/</link><pubDate>Fri, 29 Apr 2022 23:41:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/88_merge_sorted_array/</guid><description>1 Description # source: https://leetcode.com/problems/merge-sorted-array/ You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>92. Reverse Linked List II</title><link>https://ramsayleung.github.io/leetcode_book/docs/000/92_reverse_linked_list_ii/</link><pubDate>Wed, 23 Mar 2022 12:52:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/000/92_reverse_linked_list_ii/</guid><description>1 Description # source: https://leetcode.com/problems/reverse-linked-list-ii/
Given the head of a singly linked list and two integers left and right where left &amp;lt; right=, reverse the nodes of the list from position left to position right, and return the reversed list.
Example 1:
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2:
Input: head = [5], left = 1, right = 1 Output: [5] Constraints:</description></item><item><title>141. Linked list cycle</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</link><pubDate>Tue, 28 Apr 2020 09:04:58 +0000</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/141_linked_list_cycle/</guid><description>1 Description # source: https://leetcode.com/problems/linked-list-cycle/
Given a linked list, determine if it has a cycle in it.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Example 1:
Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.</description></item><item><title>143. Reorder List</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</link><pubDate>Sun, 27 Mar 2022 09:55:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/143_reorder_list/</guid><description>1 Description # source: https://leetcode.com/problems/reorder-list/ You are given the head of a singly linked-list. The list can be represented as:
L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list&amp;rsquo;s nodes. Only nodes themselves may be changed.</description></item><item><title>162. Find Peak Element</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</link><pubDate>Sat, 16 Apr 2022 09:02:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/162_find_peak_element/</guid><description>1 Description # source: https://leetcode.com/problems/find-peak-element/
A peak element is an element that is strictly greater than its neighbors.
Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞.
You must write an algorithm that runs in O(log n) time.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description></item><item><title>167. Two Sum II - Input Array Is Sorted</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/167_two_sum_ii_input_array_is_sorted/</link><pubDate>Tue, 03 May 2022 09:01:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/167_two_sum_ii_input_array_is_sorted/</guid><description>1 Description # source: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</description></item><item><title>190. Reverse Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</link><pubDate>Sun, 10 Apr 2022 20:45:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/190_reverse_bits/</guid><description>1 Description # source: https://leetcode.com/problems/reverse-bits/
Reverse bits of a given 32 bits unsigned integer.
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2&amp;rsquo;s complement notation.</description></item><item><title>191. Number of 1 Bits</title><link>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</link><pubDate>Sun, 10 Apr 2022 20:18:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/100/191_number_of_1_bits/</guid><description>1 Description # source: https://leetcode.com/problems/number-of-1-bits/
Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned.</description></item><item><title>201. Bitwise AND of Numbers Range</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/201_bitwise_and_of_numbers_range/</link><pubDate>Sun, 01 May 2022 13:54:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/201_bitwise_and_of_numbers_range/</guid><description>1 Description # source: https://leetcode.com/problems/bitwise-and-of-numbers-range/
Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.
Example 1:
Input: left = 5, right = 7 Output: 4 Example 2:
Input: left = 0, right = 0 Output: 0 Example 3:
Input: left = 1, right = 2147483647 Output: 0 Constraints:
0 &amp;lt;= left &amp;lt;= right &amp;lt;= 2^31 - 1 2 Solution # #include &amp;lt;limits&amp;gt;class Solution { public: int rangeBitwiseAnd(int left, int right) { // Time complexity: O(32) =&amp;gt; O(1) // Space complexity: O(1) if(left == 0){ return 0; } int diff_bit_count = 0; while(left !</description></item><item><title>203. Remove Linked List Elements</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/203_remove_linked_list_elements/</link><pubDate>Thu, 24 Mar 2022 21:24:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/203_remove_linked_list_elements/</guid><description>1 Description # Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example 2:
Input: head = [], val = 1 Output: [] Example 3:
Input: head = [7,7,7,7], val = 7 Output: [] Constraints:
The number of nodes in the list is in the range [0, 10^4].</description></item><item><title>229. Majority Element II</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/229_majority_element_ii/</link><pubDate>Sun, 10 Apr 2022 13:07:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/229_majority_element_ii/</guid><description>1 Description # source: https://leetcode.com/problems/majority-element-ii/
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Example 1:
Input: nums = [3,2,3] Output: [3] Example 2:
Input: nums = [1] Output: [1] Example 3:
Input: nums = [1,2] Output: [1,2] Constraints:
1 &amp;lt;= nums.length &amp;lt;= 5 * 10^4 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 Follow up: Could you solve the problem in linear time and in O(1) space?</description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/230_kth_smallest_element_in_a_bst/</link><pubDate>Fri, 29 Apr 2022 23:34:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/230_kth_smallest_element_in_a_bst/</guid><description>1 Description # source: https://leetcode.com/problems/kth-smallest-element-in-a-bst/
Given the root of a binary search tree, and an integer k, return the k^th smallest value (1-indexed) of all the values of the nodes in the tree.
Example 1:
Input: root = [3,1,4,null,2], k = 1 Output: 1 Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 Constraints:
The number of nodes in the tree is n.</description></item><item><title>231. Power of Two</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/231_power_of_two/</link><pubDate>Sun, 10 Apr 2022 21:12:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/231_power_of_two/</guid><description>1 Description # source: https://leetcode.com/problems/power-of-two/
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2^x.
Example 1:
Input: n = 1 Output: true Explanation: 20 = 1 Example 2:
Input: n = 16 Output: true Explanation: 24 = 16 Example 3:
Input: n = 3 Output: false Constraints:</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/235_lowest_common_ancestor_of_a_binary_search_tree/</link><pubDate>Sat, 30 Apr 2022 08:23:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/235_lowest_common_ancestor_of_a_binary_search_tree/</guid><description>1 Description # source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/236_lowest_common_ancestor_of_a_binary_tree/</link><pubDate>Sat, 30 Apr 2022 08:30:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/236_lowest_common_ancestor_of_a_binary_tree/</guid><description>1 Description # source: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Example 1:</description></item><item><title>260. Single Number III</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/260_single_number_iii/</link><pubDate>Sun, 01 May 2022 11:18:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/260_single_number_iii/</guid><description>1 Description # source: https://leetcode.com/problems/single-number-iii/ Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
Example 1:
Input: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer.</description></item><item><title>268. Missing Number</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/268_missing_number/</link><pubDate>Sun, 10 Apr 2022 14:17:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/268_missing_number/</guid><description>1 Description # source: https://leetcode.com/problems/missing-number/
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Example 1:
Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</description></item><item><title>278. First Bad Version</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/278_first_bad_version/</link><pubDate>Sat, 16 Apr 2022 21:05:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/278_first_bad_version/</guid><description>1 Description # source: https://leetcode.com/problems/first-bad-version/
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title>287. Find the Duplicate Number</title><link>https://ramsayleung.github.io/leetcode_book/docs/200/287_find_the_duplicate_number/</link><pubDate>Sat, 16 Apr 2022 08:49:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/200/287_find_the_duplicate_number/</guid><description>1 Description # source: https://leetcode.com/problems/find-the-duplicate-number/
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.
Example 1:
Input: nums = [1,3,4,2,2] Output: 2 Example 2:
Input: nums = [3,1,3,4,2] Output: 3 Constraints:</description></item><item><title>328. Odd Even Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/328_odd_even_linked_list/</link><pubDate>Thu, 24 Mar 2022 22:01:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/328_odd_even_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/odd-even-linked-list/ Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</description></item><item><title>342. Power of Four</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/342_power_of_four/</link><pubDate>Thu, 14 Apr 2022 22:57:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/342_power_of_four/</guid><description>1 Description # source: https://leetcode.com/problems/power-of-four/
Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4^x.
Example 1:
Input: n = 16 Output: true Example 2:
Input: n = 5 Output: false Example 3:
Input: n = 1 Output: true Constraints:
-2^31 &amp;lt;= n &amp;lt;= 2^31 - 1</description></item><item><title>374. Guess Number Higher or Lower</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/374_guess_number_higher_or_lower/</link><pubDate>Sun, 17 Apr 2022 13:09:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/374_guess_number_higher_or_lower/</guid><description>1 Description # source: https://leetcode.com/problems/guess-number-higher-or-lower/
We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns three possible results:
-1: Your guess is higher than the number I picked (i.</description></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/378_kth_smallest_element_in_a_sorted_matrix/</link><pubDate>Fri, 29 Apr 2022 22:55:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/378_kth_smallest_element_in_a_sorted_matrix/</guid><description>1 Description # source: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^th smallest element in the matrix.
Note that it is the k^th smallest element in the sorted order, not the k^th distinct element.
You must find a solution with a memory complexity better than O(n^2).
Example 1:
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output: 13 Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 Example 2:</description></item><item><title>383. Ransom Note</title><link>https://ramsayleung.github.io/leetcode_book/docs/300/383_ransom_note/</link><pubDate>Sun, 08 May 2022 08:04:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/300/383_ransom_note/</guid><description>1 Description # source: https://leetcode.com/problems/ransom-note/
Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.
Example 1:
Input: ransomNote = &amp;#34;a&amp;#34;, magazine = &amp;#34;b&amp;#34; Output: false Example 2:
Input: ransomNote = &amp;#34;aa&amp;#34;, magazine = &amp;#34;ab&amp;#34; Output: false Example 3:
Input: ransomNote = &amp;#34;aa&amp;#34;, magazine = &amp;#34;aab&amp;#34; Output: true Constraints:
1 &amp;lt;= ransomNote.</description></item><item><title>405. Convert a Number to Hexadecimal</title><link>https://ramsayleung.github.io/leetcode_book/docs/400/405_convert_a_number_to_hexadecimal/</link><pubDate>Tue, 03 May 2022 08:56:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/400/405_convert_a_number_to_hexadecimal/</guid><description>1 Description # source: https://leetcode.com/problems/convert-a-number-to-hexadecimal/
Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.
Note: You are not allowed to use any built-in library method to directly solve this problem.
Example 1:</description></item><item><title>692. Top K Frequent Words</title><link>https://ramsayleung.github.io/leetcode_book/docs/600/692_top_k_frequent_words/</link><pubDate>Fri, 29 Apr 2022 23:25:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/600/692_top_k_frequent_words/</guid><description>1 Description # source: https://leetcode.com/problems/top-k-frequent-words/
Given an array of strings words and an integer k, return the k most frequent strings.
Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.
Example 1:
Input: words = [&amp;#34;i&amp;#34;,&amp;#34;love&amp;#34;,&amp;#34;leetcode&amp;#34;,&amp;#34;i&amp;#34;,&amp;#34;love&amp;#34;,&amp;#34;coding&amp;#34;], k = 2 Output: [&amp;#34;i&amp;#34;,&amp;#34;love&amp;#34;] Explanation: &amp;#34;i&amp;#34; and &amp;#34;love&amp;#34; are the two most frequent words. Note that &amp;#34;i&amp;#34; comes before &amp;#34;love&amp;#34; due to a lower alphabetical order.</description></item><item><title>1721. Swapping Nodes in a Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/1700/1721_swapping_nodes_in_a_linked_list/</link><pubDate>Tue, 22 Mar 2022 21:49:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/1700/1721_swapping_nodes_in_a_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
Example 1:
Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Constraints:</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://ramsayleung.github.io/leetcode_book/docs/2000/2095_delete_the_middle_node_of_a_linked_list/</link><pubDate>Sun, 27 Mar 2022 10:37:00 +0800</pubDate><guid>https://ramsayleung.github.io/leetcode_book/docs/2000/2095_delete_the_middle_node_of_a_linked_list/</guid><description>1 Description # source: https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/
You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.
The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.
For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.</description></item></channel></rss>