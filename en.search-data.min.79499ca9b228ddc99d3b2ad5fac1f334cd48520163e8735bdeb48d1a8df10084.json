[{"id":0,"href":"/docs/000/2_add_two_numbers/","title":"2. Add two number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807. 2 Solution #  Solution in Python3:\n# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None  # Runtime: 72 ms, faster than 62.00% of Python3 online submissions for Add Two Numbers. # time complexity: O(n1+n2), n1 is the length of l1, n2 is the length of l2 # space complexity: O(max(n1,n2)), the length of sum of two number equals the larger\u0026#39;s   class Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: \tnum1 = self.getNumber(l1) \tnum2 = self.getNumber(l2) \tresult = num1+num2 \treturn self.constructNumber(result)   def getNumber(self, llist: ListNode) -\u0026gt; int: \tnum = \u0026#34;\u0026#34; \twhile llist: \tnum = str(llist.val) + num \tllist = llist.next \treturn int(num)   def constructNumber(self, num: int) -\u0026gt; ListNode: \tprint(num) \tinput = str(num) \tparent = root = None \twhile len(input) \u0026gt; 0: \tval = input[len(input)-1] \tnewNode = ListNode(int(val)) \tif not parent: \tparent = newNode \troot = parent \telse: \tparent.next = newNode \tparent = newNode \tinput = input[:len(input)-1] \treturn root Solution in C++:\n  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { \t// Runtime complexity O(n), n = max(l1.size(), l2.size()) \t// Space complexity O(1)  \tListNode* result = l1; \tListNode* prev = nullptr; \tint carry = 0; \twhile(l1 || l2){ \tint add_result = 0; \tif (l1){ \tadd_result += l1 -\u0026gt; val; \t}  \tif (l2){ \tadd_result += l2 -\u0026gt; val; \t} \tadd_result += carry;  \tListNode* head = (l1 != nullptr? l1: l2);  \tif(add_result % 10 == add_result){ \thead -\u0026gt; val = add_result; \tcarry =0; \t}else{ \thead -\u0026gt; val = add_result % 10; \tcarry =1; \t}  \tif(!prev){ \tprev = l1; \t}else{ \tprev-\u0026gt; next = head; \tprev = prev -\u0026gt; next; \t}  \tl1 = l1 != nullptr? l1 -\u0026gt; next: l1; \tl2 = l2 != nullptr? l2 -\u0026gt; next: l2; \t}  \tif(carry !=0 ){ \tprev -\u0026gt; next = new ListNode(carry); \t}  \treturn result;  } }; "},{"id":1,"href":"/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":2,"href":"/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "},{"id":3,"href":"/docs/000/24_swap_nodes_in_pairs/","title":"24. Swap Nodes in Pairs","section":"0th","content":"1 Description #  Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\n Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1] Constraints:\n The number of nodes in the list is in the range [0, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapPairs(ListNode* head) {  // Time complexity: O(N) N = S / 2, S is the length of linked-list  // Space Complexity: O(1)  if(!head || !head-\u0026gt;next){  return head;  }   ListNode* result = head-\u0026gt;next;  ListNode* prev = nullptr;  while(head){  auto right = head-\u0026gt;next;  if(right){ \thead-\u0026gt;next = right-\u0026gt;next; \tright-\u0026gt;next = head; \tif (prev){ \tprev-\u0026gt;next = right; \t}  }   prev = head;  head= head-\u0026gt;next;  }   return result;  } }; "},{"id":4,"href":"/docs/000/26_remove_duplicates_from_sorted_array/","title":"26. Remove Duplicates from Sorted Array","section":"0th","content":"1 Description #  Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length  int k = removeDuplicates(nums); // Calls your implementation  assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) {  assert nums[i] == expectedNums[i];  } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order.  2 Soltuion #  Even though it works, it\u0026rsquo;s not a good solution\nclass Solution { public:  int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int k = 0;  int prev = -101;  auto iter = nums.begin();  while(iter != nums.end()){  if(prev == *iter){ \tnums.erase(iter);  }else{ \tk++; \tprev = *iter; \titer ++;  }   }   return k;  } }; "},{"id":5,"href":"/docs/000/43.multiply_strings/","title":"43. Multiply String","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \u0026#34;2\u0026#34;, num2 = \u0026#34;3\u0026#34; Output: \u0026#34;6\u0026#34; Example 2:\nInput: num1 = \u0026#34;123\u0026#34;, num2 = \u0026#34;456\u0026#34; Output: \u0026#34;56088\u0026#34; Constraints:\n 1 \u0026lt;= num1.length, num2.length \u0026lt;= 200 num1 and num2 consist of digits only. Both num1 and num2 do not contain any leading zero, except the number 0 itself.  2 Solution #  A not good solution\n#include \u0026lt;cmath\u0026gt;#include \u0026lt;string\u0026gt;class Solution { public:  string multiply(string num1, string num2) {  if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) {  return \u0026#34;0\u0026#34;;  }  int size1 = num1.size();  int size2 = num2.size();  auto p_str1 = num1.c_str();  auto p_str2 = num2.c_str();  std::string final_result;  for (int j = size2 - 1; j \u0026gt;= 0; j--) {  std::string result;  for (int i = size1 - 1; i \u0026gt;= 0; i--) { \tint multiply_result = (p_str1[i] - \u0026#39;0\u0026#39;) * (p_str2[j] - \u0026#39;0\u0026#39;); \tresult = add(result, std::to_string(multiply_result) + \tstd::string(size1 - 1 - i, \u0026#39;0\u0026#39;));  }  final_result = \tadd(final_result, result + std::string(size2 - 1 - j, \u0026#39;0\u0026#39;));  }  return final_result;  }   std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) {  auto p1 = num1.c_str();  auto p2 = num2.c_str();  int size1 = num1.size();  int size2 = num2.size();  int i = 0, j = 0, k = 0;  std::string result = (size1 \u0026gt; size2 ? num1 : num2);  auto p_res = result.c_str();  int carry = 0;  for (k = result.size() - 1, i = size1 - 1, j = size2 - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = (p1[i] - \u0026#39;0\u0026#39;) + (p2[j] - \u0026#39;0\u0026#39;) + carry;  if (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0;  } else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1;  }  }   if (i \u0026gt; 0) {  for (i; i \u0026gt;= 0; i--, k--) { \tint add_result = carry + (p1[i] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else if (j \u0026gt; 0) {  for (j; j \u0026gt;= 0; j--, k--) { \tint add_result = carry + (p2[j] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else {  if (carry != 0) { \tif (k \u0026lt; 0) { \treturn \u0026#39;1\u0026#39; + result; \t} else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \treturn result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \treturn \u0026#39;1\u0026#39; + result; \t} \t}  }  }   if (carry != 0) {  if (k \u0026lt; 0) { \tresult = \u0026#39;1\u0026#39; + result;  } else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tresult = \u0026#39;1\u0026#39; + result; \t}  }  }  return result;  } }; "},{"id":6,"href":"/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* rotateRight(ListNode* head, int k) {  // time complexity: O(n)  // space complexity: O(1)   if (k == 0 || !head){  return head;  }   int size = 0;  ListNode* first = head;  ListNode* last_node = head;  while(first){  if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ \tlast_node = first;  }  first = first -\u0026gt; next;   size ++;  }   // it will be the same linked_list after rotate `size` steps  k = k % size;  if(k ==0){  return head;  }   // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head;  for(int i = 0; i \u0026lt; size - k - 1; i++){  k_minus_1 = k_minus_1 -\u0026gt;next;  }   ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr;  last_node -\u0026gt; next = head;   return k_node;  } }; "},{"id":7,"href":"/docs/000/67_add_binary/","title":"67. Add Binary","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\nInput: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; Constraints:\n 1 \u0026lt;= a.length, b.length \u0026lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.  2 Solution #    class Solution { public:  string addBinary(string a, string b) {  // runtime complexity: O(N), N = max(a.size(), b.size());  // space complexity: O(N), N = max(a.size(), b.size());  auto p_a = a.c_str();  auto p_b = b.c_str();  auto sizea = a.size();  auto sizeb = b.size();  std::string result = (sizea \u0026gt; sizeb ? a : b);  int i = 0, j = 0, k = 0;  int carry = 0;   for (i = sizea - 1, j = sizeb - 1, k = result.size() - 1; i \u0026gt;= 0 || j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = 0;  if (i \u0026gt;= 0) { \tadd_result += p_a[i] - \u0026#39;0\u0026#39;;  }  if (j \u0026gt;= 0) { \tadd_result += p_b[j] - \u0026#39;0\u0026#39;;  }   add_result += carry;  if (add_result % 2 == add_result) { \tresult[k] = add_result + \u0026#39;0\u0026#39;; \tcarry = 0;  } else { \tresult[k] = add_result % 2 + \u0026#39;0\u0026#39;; \tcarry = 1;  }  }   if (carry != 0) {  result = \u0026#39;1\u0026#39; + result;  }  return result;  } }; "},{"id":8,"href":"/docs/000/83_remove_duplicates_from_sorted_list/","title":"83. Remove Duplicates from Sorted List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-list/\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\n Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:\n The number of nodes in the list is in the range [0, 300]. -100 \u0026lt;= Node.val \u0026lt;= 100 The list is guaranteed to be sorted in ascending order.  2 Solution #  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteDuplicates(ListNode* head) {  // time complexity: O(N): N is size of linked list  // space compleixty: O(1)  if(!head){  return head;  }   ListNode* prev = nullptr;  ListNode* result = head;  while(head){  if(!prev){ \tprev = head; \tcontinue;  }   if(prev-\u0026gt;val != head-\u0026gt;val){ \tprev-\u0026gt;next = head; \tprev = prev-\u0026gt;next;  }else{ \t// delete the last duplicate node \tif(!head-\u0026gt;next){ \tprev -\u0026gt; next = nullptr; \treturn result; \t}  }   head = head -\u0026gt; next;  }   return result;  } }; "},{"id":9,"href":"/docs/000/92_reverse_linked_list_ii/","title":"92. Reverse Linked List II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/reverse-linked-list-ii/\nGiven the head of a singly linked list and two integers left and right where left \u0026lt; right=, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\n Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2:\nInput: head = [5], left = 1, right = 1 Output: [5] Constraints:\nThe number of nodes in the list is n.\n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* reverseBetween(ListNode* head, int left, int right) {  // time complexity: O(2N), N = size of the linked list  // space compleixty: O(1)  if(!head || left == right){  return head;  }   ListNode* left_prev = nullptr;  ListNode* left_node = nullptr;  ListNode* right_node = nullptr;  ListNode* result = nullptr;   int size = 0;  while(head){  size ++;  if(!result \u0026amp;\u0026amp; size \u0026lt;= left - 1){ \tresult = head;  }  if(size == left - 1){ \tleft_prev = head;  }   if(size == left){ \tleft_node = head;  }    if(size == right){ \tright_node = head;  }   head = head-\u0026gt;next;  }   ListNode* right_node_next = right_node -\u0026gt; next;  right_node-\u0026gt; next = nullptr;  if(!result){  result = right_node;  }   while(left_node){  ListNode* left_next = left_node-\u0026gt;next;  left_node-\u0026gt;next = right_node_next;  right_node_next = left_node;  if(!left_next \u0026amp;\u0026amp; left_prev){ \tleft_prev -\u0026gt; next = left_node;  }  left_node = left_next;  }     return result;  } }; "},{"id":10,"href":"/docs/1700/","title":"1700th","section":"Docs","content":"1 Leetcode 1700-1799 #  "},{"id":11,"href":"/docs/1700/1721_swapping_nodes_in_a_linked_list/","title":"1721. Swapping Nodes in a Linked List","section":"1700th","content":"1 Description #  source: https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ You are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Constraints:\n The number of nodes in the list is n. 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapNodes(ListNode* head, int k) {  // time complexity: O(2N) = O(N), N = size of linked list  // space compleixty(1)  int size = 0;  ListNode* first = head;  ListNode* kth_from_begin = nullptr;  ListNode* kth_from_end = nullptr;  while(first){  size++;  if(size == k){ \tkth_from_begin = first;  }   first = first-\u0026gt;next;  }    int next_round_size = 0;  first = head;  while(first){  next_round_size++;    if(next_round_size == size - k + 1){ \tkth_from_end = first; \tbreak;  }  first = first-\u0026gt;next;  }   int tmp = kth_from_begin -\u0026gt; val;  kth_from_begin-\u0026gt;val = kth_from_end-\u0026gt;val;  kth_from_end -\u0026gt; val = tmp;   return head;  } }; "},{"id":12,"href":"/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution:  def hasCycle(self, head: ListNode) -\u0026gt; bool: \tseen = set() \twhile head: \tif head in seen: \treturn True \tseen.add(head) \thead = head.next \treturn False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public:  bool hasCycle(ListNode *head) {  // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){  return false;  }   ListNode* fast = head -\u0026gt; next;  while(head){  // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ \treturn true;  }   if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ \tfast = fast-\u0026gt;next-\u0026gt;next;  } else{ \t// if there is a cycle, the fast-\u0026gt; next will never be null \treturn false;  }   head = head-\u0026gt;next;  }   return false;  } }; "}]