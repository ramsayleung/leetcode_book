[{"id":0,"href":"/docs/000/2_add_two_numbers/","title":"2. Add two number","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807. 2 Solution #  Solution in Python3:\n# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None  # Runtime: 72 ms, faster than 62.00% of Python3 online submissions for Add Two Numbers. # time complexity: O(n1+n2), n1 is the length of l1, n2 is the length of l2 # space complexity: O(max(n1,n2)), the length of sum of two number equals the larger\u0026#39;s   class Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: \tnum1 = self.getNumber(l1) \tnum2 = self.getNumber(l2) \tresult = num1+num2 \treturn self.constructNumber(result)   def getNumber(self, llist: ListNode) -\u0026gt; int: \tnum = \u0026#34;\u0026#34; \twhile llist: \tnum = str(llist.val) + num \tllist = llist.next \treturn int(num)   def constructNumber(self, num: int) -\u0026gt; ListNode: \tprint(num) \tinput = str(num) \tparent = root = None \twhile len(input) \u0026gt; 0: \tval = input[len(input)-1] \tnewNode = ListNode(int(val)) \tif not parent: \tparent = newNode \troot = parent \telse: \tparent.next = newNode \tparent = newNode \tinput = input[:len(input)-1] \treturn root Solution in C++:\n  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { \t// Runtime complexity O(n), n = max(l1.size(), l2.size()) \t// Space complexity O(1)  \tListNode* result = l1; \tListNode* prev = nullptr; \tint carry = 0; \twhile(l1 || l2){ \tint add_result = 0; \tif (l1){ \tadd_result += l1 -\u0026gt; val; \t}  \tif (l2){ \tadd_result += l2 -\u0026gt; val; \t} \tadd_result += carry;  \tListNode* head = (l1 != nullptr? l1: l2);  \tif(add_result % 10 == add_result){ \thead -\u0026gt; val = add_result; \tcarry =0; \t}else{ \thead -\u0026gt; val = add_result % 10; \tcarry =1; \t}  \tif(!prev){ \tprev = l1; \t}else{ \tprev-\u0026gt; next = head; \tprev = prev -\u0026gt; next; \t}  \tl1 = l1 != nullptr? l1 -\u0026gt; next: l1; \tl2 = l2 != nullptr? l2 -\u0026gt; next: l2; \t}  \tif(carry !=0 ){ \tprev -\u0026gt; next = new ListNode(carry); \t}  \treturn result;  } }; "},{"id":1,"href":"/docs/000/","title":"0th","section":"Docs","content":"1 Leetcode 0-99 #  "},{"id":2,"href":"/docs/000/12_integer_to_roman/","title":"12. Integer to Roman","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/integer-to-roman/\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral.\nExample 1:\nInput: num = 3 Output: \u0026#34;III\u0026#34; Explanation: 3 is represented as 3 ones. Example 2:\nInput: num = 58 Output: \u0026#34;LVIII\u0026#34; Explanation: L = 50, V = 5, III = 3. Example 3:\nInput: num = 1994 Output: \u0026#34;MCMXCIV\u0026#34; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n 1 \u0026lt;= num \u0026lt;= 3999  2 Solution #  #include \u0026lt;sstream\u0026gt;#include \u0026lt;utility\u0026gt;#include \u0026lt;vector\u0026gt;class Solution { public:  string intToRoman(int num) { \t// Runtime complexity: O(n), n is time to divide num. \t// Space complexity: O(n) \tstatic std::vector\u0026lt;std::pair\u0026lt;std::string, int\u0026gt;\u0026gt; rimap{ \t{\u0026#34;M\u0026#34;, 1000}, \t{\u0026#34;CM\u0026#34;, 900}, \t{\u0026#34;D\u0026#34;, 500}, \t{\u0026#34;CD\u0026#34;, 400}, \t{\u0026#34;C\u0026#34;, 100}, \t{\u0026#34;XC\u0026#34;, 90}, \t{\u0026#34;L\u0026#34;, 50}, \t{\u0026#34;XL\u0026#34;, 40}, \t{\u0026#34;X\u0026#34;, 10}, \t{\u0026#34;IX\u0026#34;, 9}, \t{\u0026#34;V\u0026#34;, 5}, \t{\u0026#34;IV\u0026#34;, 4}, \t{\u0026#34;I\u0026#34;, 1} \t};  \tstd::stringstream result; \twhile(num \u0026gt; 0){ \tfor(auto iter = rimap.begin(); iter != rimap.end(); iter++){ \tif(num \u0026gt;= iter-\u0026gt;second){ \tint times = num / iter-\u0026gt; second; \trepeat(times, iter-\u0026gt;first, result); \tnum = num % iter-\u0026gt;second; \t} \t} \t} \treturn result.str();  }   void repeat(int times, const std::string\u0026amp; source, std::stringstream\u0026amp; stream){ \twhile(times \u0026gt; 0){ \tstream \u0026lt;\u0026lt; source; \ttimes --; \t}  } }; "},{"id":3,"href":"/docs/100/","title":"100th","section":"Docs","content":"1 Leetcode 100-199 #  "},{"id":4,"href":"/docs/000/24_swap_nodes_in_pairs/","title":"24. Swap Nodes in Pairs","section":"0th","content":"1 Description #  Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\n Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1] Constraints:\n The number of nodes in the list is in the range [0, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapPairs(ListNode* head) {  // Time complexity: O(N) N = S / 2, S is the length of linked-list  // Space Complexity: O(1)  if(!head || !head-\u0026gt;next){  return head;  }   ListNode* result = head-\u0026gt;next;  ListNode* prev = nullptr;  while(head){  auto right = head-\u0026gt;next;  if(right){ \thead-\u0026gt;next = right-\u0026gt;next; \tright-\u0026gt;next = head; \tif (prev){ \tprev-\u0026gt;next = right; \t}  }   prev = head;  head= head-\u0026gt;next;  }   return result;  } }; "},{"id":5,"href":"/docs/000/26_remove_duplicates_from_sorted_array/","title":"26. Remove Duplicates from Sorted Array","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length  int k = removeDuplicates(nums); // Calls your implementation  assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) {  assert nums[i] == expectedNums[i];  } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order.  2 Soltuion #  Even though it works, it\u0026rsquo;s not a good solution\nclass Solution { public:  int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  if(nums.size() == 0){  return 0;  }   int prev = -101;  auto iter = nums.begin();   while(iter != nums.end()){  if(prev == *iter){ \tstd::remove(iter, nums.end(), prev);  }   if(*iter == *(nums.end() - 1)){ \treturn iter - nums.begin() + 1;  }   prev = *iter;  iter++;  }   return iter - nums.begin() + 1;  } }; "},{"id":6,"href":"/docs/000/43.multiply_strings/","title":"43. Multiply String","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \u0026#34;2\u0026#34;, num2 = \u0026#34;3\u0026#34; Output: \u0026#34;6\u0026#34; Example 2:\nInput: num1 = \u0026#34;123\u0026#34;, num2 = \u0026#34;456\u0026#34; Output: \u0026#34;56088\u0026#34; Constraints:\n 1 \u0026lt;= num1.length, num2.length \u0026lt;= 200 num1 and num2 consist of digits only. Both num1 and num2 do not contain any leading zero, except the number 0 itself.  2 Solution #  A not good solution\n#include \u0026lt;cmath\u0026gt;#include \u0026lt;string\u0026gt;class Solution { public:  string multiply(string num1, string num2) {  if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) {  return \u0026#34;0\u0026#34;;  }  int size1 = num1.size();  int size2 = num2.size();  auto p_str1 = num1.c_str();  auto p_str2 = num2.c_str();  std::string final_result;  for (int j = size2 - 1; j \u0026gt;= 0; j--) {  std::string result;  for (int i = size1 - 1; i \u0026gt;= 0; i--) { \tint multiply_result = (p_str1[i] - \u0026#39;0\u0026#39;) * (p_str2[j] - \u0026#39;0\u0026#39;); \tresult = add(result, std::to_string(multiply_result) + \tstd::string(size1 - 1 - i, \u0026#39;0\u0026#39;));  }  final_result = \tadd(final_result, result + std::string(size2 - 1 - j, \u0026#39;0\u0026#39;));  }  return final_result;  }   std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) {  auto p1 = num1.c_str();  auto p2 = num2.c_str();  int size1 = num1.size();  int size2 = num2.size();  int i = 0, j = 0, k = 0;  std::string result = (size1 \u0026gt; size2 ? num1 : num2);  auto p_res = result.c_str();  int carry = 0;  for (k = result.size() - 1, i = size1 - 1, j = size2 - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = (p1[i] - \u0026#39;0\u0026#39;) + (p2[j] - \u0026#39;0\u0026#39;) + carry;  if (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0;  } else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1;  }  }   if (i \u0026gt; 0) {  for (i; i \u0026gt;= 0; i--, k--) { \tint add_result = carry + (p1[i] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else if (j \u0026gt; 0) {  for (j; j \u0026gt;= 0; j--, k--) { \tint add_result = carry + (p2[j] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \tcarry = 0; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tcarry = 1; \t}  }  } else {  if (carry != 0) { \tif (k \u0026lt; 0) { \treturn \u0026#39;1\u0026#39; + result; \t} else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \treturn result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \treturn \u0026#39;1\u0026#39; + result; \t} \t}  }  }   if (carry != 0) {  if (k \u0026lt; 0) { \tresult = \u0026#39;1\u0026#39; + result;  } else { \t// k should be zero \tint add_result = 1 + (result[k] - \u0026#39;0\u0026#39;); \tif (add_result % 10 == add_result) { \tresult[k] = \u0026#39;0\u0026#39; + add_result; \t} else { \tresult[k] = \u0026#39;0\u0026#39; + add_result % 10; \tresult = \u0026#39;1\u0026#39; + result; \t}  }  }  return result;  } }; "},{"id":7,"href":"/docs/000/61_rotate_list/","title":"61. Rotate List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/rotate-list/\nGiven the head of a linked list, rotate the list to the right by k places.\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\n Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:\n The number of nodes in the list is in the range [0, 500]. -100 \u0026lt;= Node.val \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 2 * 10^9  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* rotateRight(ListNode* head, int k) {  // time complexity: O(n)  // space complexity: O(1)   if (k == 0 || !head){  return head;  }   int size = 0;  ListNode* first = head;  ListNode* last_node = head;  while(first){  if(first \u0026amp;\u0026amp; nullptr == first-\u0026gt;next){ \tlast_node = first;  }  first = first -\u0026gt; next;   size ++;  }   // it will be the same linked_list after rotate `size` steps  k = k % size;  if(k ==0){  return head;  }   // split the linked list into two single linked lists by the rotate point;  ListNode* k_minus_1 = head;  for(int i = 0; i \u0026lt; size - k - 1; i++){  k_minus_1 = k_minus_1 -\u0026gt;next;  }   ListNode* k_node = k_minus_1 -\u0026gt; next; // the rotate point  k_minus_1 -\u0026gt; next = nullptr;  last_node -\u0026gt; next = head;   return k_node;  } }; "},{"id":8,"href":"/docs/000/67_add_binary/","title":"67. Add Binary","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/add-binary/ Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\nInput: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; Constraints:\n 1 \u0026lt;= a.length, b.length \u0026lt;= 10^4 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself.  2 Solution #    class Solution { public:  string addBinary(string a, string b) {  // runtime complexity: O(N), N = max(a.size(), b.size());  // space complexity: O(N), N = max(a.size(), b.size());  auto p_a = a.c_str();  auto p_b = b.c_str();  auto sizea = a.size();  auto sizeb = b.size();  std::string result = (sizea \u0026gt; sizeb ? a : b);  int i = 0, j = 0, k = 0;  int carry = 0;   for (i = sizea - 1, j = sizeb - 1, k = result.size() - 1; i \u0026gt;= 0 || j \u0026gt;= 0; \ti--, j--, k--) {  int add_result = 0;  if (i \u0026gt;= 0) { \tadd_result += p_a[i] - \u0026#39;0\u0026#39;;  }  if (j \u0026gt;= 0) { \tadd_result += p_b[j] - \u0026#39;0\u0026#39;;  }   add_result += carry;  if (add_result % 2 == add_result) { \tresult[k] = add_result + \u0026#39;0\u0026#39;; \tcarry = 0;  } else { \tresult[k] = add_result % 2 + \u0026#39;0\u0026#39;; \tcarry = 1;  }  }   if (carry != 0) {  result = \u0026#39;1\u0026#39; + result;  }  return result;  } }; "},{"id":9,"href":"/docs/000/83_remove_duplicates_from_sorted_list/","title":"83. Remove Duplicates from Sorted List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/remove-duplicates-from-sorted-list/\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\n Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:\n The number of nodes in the list is in the range [0, 300]. -100 \u0026lt;= Node.val \u0026lt;= 100 The list is guaranteed to be sorted in ascending order.  2 Solution #  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteDuplicates(ListNode* head) {  // time complexity: O(N): N is size of linked list  // space compleixty: O(1)  if(!head){  return head;  }   ListNode* prev = nullptr;  ListNode* result = head;  while(head){  if(!prev){ \tprev = head; \tcontinue;  }   if(prev-\u0026gt;val != head-\u0026gt;val){ \tprev-\u0026gt;next = head; \tprev = prev-\u0026gt;next;  }else{ \t// delete the last duplicate node \tif(!head-\u0026gt;next){ \tprev -\u0026gt; next = nullptr; \treturn result; \t}  }   head = head -\u0026gt; next;  }   return result;  } }; "},{"id":10,"href":"/docs/000/86_partition_list/","title":"86. Partition List","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/partition-list/\nGiven the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\n Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2:\nInput: head = [2,1], x = 2 Output: [1,2] Constraints:\n The number of nodes in the list is in the range [0, 200]. -100 \u0026lt;= Node.val \u0026lt;= 100 -200 \u0026lt;= x \u0026lt;= 200  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode *partition(ListNode *head, int x) {  // Time complexity: O(N), N is the size of linked_list  // Space complexity: O(1)  if (!head) {  return head;  }   ListNode *first_less_x = nullptr;  ListNode *last_less_x = nullptr;  ListNode *last_greater_x = nullptr;  ListNode *first_greater_x = nullptr;  while (head) {  if (head-\u0026gt;val \u0026lt; x) { \tfirst_less_x = (first_less_x == nullptr ? head : first_less_x);  \tif (!last_less_x) { \tlast_less_x = head;  \t} else { \tlast_less_x-\u0026gt;next = head; \tlast_less_x = last_less_x-\u0026gt;next; \t}  } else { \tfirst_greater_x = (first_greater_x == nullptr ? head : first_greater_x);  \tif (!last_greater_x) { \tlast_greater_x = head; \t} else { \tlast_greater_x-\u0026gt;next = head; \tlast_greater_x = last_greater_x-\u0026gt;next; \t}  }   head = head-\u0026gt;next;  }   if (last_greater_x) {  last_greater_x-\u0026gt;next = nullptr;  }   if (last_less_x) {  last_less_x-\u0026gt;next = first_greater_x;  }   return first_less_x != nullptr ? first_less_x : first_greater_x;  } }; "},{"id":11,"href":"/docs/000/92_reverse_linked_list_ii/","title":"92. Reverse Linked List II","section":"0th","content":"1 Description #  source: https://leetcode.com/problems/reverse-linked-list-ii/\nGiven the head of a singly linked list and two integers left and right where left \u0026lt; right=, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\n Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2:\nInput: head = [5], left = 1, right = 1 Output: [5] Constraints:\nThe number of nodes in the list is n.\n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* reverseBetween(ListNode* head, int left, int right) {  // time complexity: O(2N), N = size of the linked list  // space compleixty: O(1)  if(!head || left == right){  return head;  }   ListNode* left_prev = nullptr;  ListNode* left_node = nullptr;  ListNode* right_node = nullptr;  ListNode* result = nullptr;   int size = 0;  while(head){  size ++;  if(!result \u0026amp;\u0026amp; size \u0026lt;= left - 1){ \tresult = head;  }  if(size == left - 1){ \tleft_prev = head;  }   if(size == left){ \tleft_node = head;  }    if(size == right){ \tright_node = head;  }   head = head-\u0026gt;next;  }   ListNode* right_node_next = right_node -\u0026gt; next;  right_node-\u0026gt; next = nullptr;  if(!result){  result = right_node;  }   while(left_node){  ListNode* left_next = left_node-\u0026gt;next;  left_node-\u0026gt;next = right_node_next;  right_node_next = left_node;  if(!left_next \u0026amp;\u0026amp; left_prev){ \tleft_prev -\u0026gt; next = left_node;  }  left_node = left_next;  }     return result;  } }; "},{"id":12,"href":"/docs/100/141_linked_list_cycle/","title":"141. Linked list cycle","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/linked-list-cycle/\nGiven a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.  Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.  Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.  Follow up:\nCan you solve it using O(1) (i.e. constant) memory?\n2 Solution #  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # time complexity: O(n), n is the length of linkedList # space complexity: O(n), n is the size of seen set. class Solution:  def hasCycle(self, head: ListNode) -\u0026gt; bool: \tseen = set() \twhile head: \tif head in seen: \treturn True \tseen.add(head) \thead = head.next \treturn False /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public:  bool hasCycle(ListNode *head) {  // Runtime complexity: O(n); n is the size of linked_list  // Space complexity: O(1)  if(!head){  return false;  }   ListNode* fast = head -\u0026gt; next;  while(head){  // if the fast pointer meets the slow pointer, there is a cycle  if (fast == head){ \treturn true;  }   if(fast \u0026amp;\u0026amp; fast -\u0026gt;next){ \tfast = fast-\u0026gt;next-\u0026gt;next;  } else{ \t// if there is a cycle, the fast-\u0026gt; next will never be null \treturn false;  }   head = head-\u0026gt;next;  }   return false;  } }; "},{"id":13,"href":"/docs/100/143_reorder_list/","title":"143. Reorder List","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/reorder-list/ You are given the head of a singly linked-list. The list can be represented as:\nL0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list\u0026rsquo;s nodes. Only nodes themselves may be changed.\nExample 1:\n Input: head = [1,2,3,4] Output: [1,4,2,3] Example 2:\n Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] Constraints:\n The number of nodes in the list is in the range [1, 5 * 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 1000  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #include \u0026lt;deque\u0026gt;class Solution { public:  void reorderList(ListNode* head) {  // Time complexity: O(2N), N is the size of linked list  // Space complexity: O(N), N is the size of linked list  std::deque\u0026lt;ListNode*\u0026gt; head_deque;  while(head){  head_deque.push_back(head);  head = head-\u0026gt;next;  }   ListNode* prev = nullptr;  ListNode* node = nullptr;  bool first_last_flag = true;   while(!head_deque.empty()){  if(first_last_flag){ \tnode = head_deque.front(); \thead_deque.pop_front();  }else{ \tnode = head_deque.back(); \thead_deque.pop_back();  }   node -\u0026gt; next = nullptr;  first_last_flag = !first_last_flag;   if(prev){ \tprev-\u0026gt;next = node; \tprev = prev-\u0026gt;next;  }else{ \tprev = node;  }   if(!head){ \thead = node;  }  }  } }; "},{"id":14,"href":"/docs/100/190_reverse_bits/","title":"190. Reverse Bits","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/reverse-bits/\nReverse bits of a given 32 bits unsigned integer.\nNote:\n Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer\u0026rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.  Example 1:\nInput: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2:\nInput: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints:\n The input must be a binary string of length 32  Follow up: If this function is called many times, how would you optimize it?\n2 Solution #  #include \u0026lt;bitset\u0026gt;#include \u0026lt;sstream\u0026gt;class Solution { public:  uint32_t reverseBits(uint32_t n) { \tstd::string bin_str = std::bitset\u0026lt;32\u0026gt;(n).to_string(); \tstd::stringstream ss; \tfor(int i = bin_str.size() -1 ; i \u0026gt;= 0; i--){ \tss \u0026lt;\u0026lt; bin_str[i]; \t} \tstd::bitset\u0026lt;32\u0026gt; result{ss.str()}; \treturn result.to_ulong();  } }; "},{"id":15,"href":"/docs/100/191_number_of_1_bits/","title":"191. Number of 1 Bits","section":"100th","content":"1 Description #  source: https://leetcode.com/problems/number-of-1-bits/\nWrite a function that takes an unsigned integer and returns the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight).\nNote:\n Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer\u0026rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.  Example 1:\nInput: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three \u0026#39;1\u0026#39; bits. Example 2:\nInput: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one \u0026#39;1\u0026#39; bit. Example 3:\nInput: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one \u0026#39;1\u0026#39; bits. Constraints:\n The input must be a binary string of length 32.  Follow up: If this function is called many times, how would you optimize it?\n2 Solution #  #include \u0026lt;bitset\u0026gt;class Solution { public:  int hammingWeight(uint32_t n) { \tstd::bitset\u0026lt;32\u0026gt; binary = std::bitset\u0026lt;32\u0026gt;(n); \treturn binary.count();  } }; "},{"id":16,"href":"/docs/200/","title":"200th","section":"Docs","content":"1 Leetcode 200-299 #  "},{"id":17,"href":"/docs/200/203_remove_linked_list_elements/","title":"203. Remove Linked List Elements","section":"200th","content":"1 Description #  Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\nExample 1:\n Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example 2:\nInput: head = [], val = 1 Output: [] Example 3:\nInput: head = [7,7,7,7], val = 7 Output: [] Constraints:\n The number of nodes in the list is in the range [0, 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 50  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* removeElements(ListNode* head, int val) {  // Time complexity: O(N), N is the size of linked list  // Space complexity: O(1)  if(!head){  return head;  }   ListNode* prev = nullptr;  ListNode* result = nullptr;  while(head){  if(head-\u0026gt;val == val){ \tif(prev){ \tprev-\u0026gt;next = head-\u0026gt;next; \thead = head-\u0026gt;next; \t}else{ \tListNode* next = head-\u0026gt;next; \thead-\u0026gt;next = nullptr; \thead = next; \t}  }else{ \tprev = head; \thead = head-\u0026gt;next;  }   result = (result ==nullptr? prev: result);  }   return result;  } }; "},{"id":18,"href":"/docs/200/229_majority_element_ii/","title":"229. Majority Element II","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/majority-element-ii/\nGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\nExample 1:\nInput: nums = [3,2,3] Output: [3] Example 2:\nInput: nums = [1] Output: [1] Example 3:\nInput: nums = [1,2] Output: [1,2] Constraints:\n 1 \u0026lt;= nums.length \u0026lt;= 5 * 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9  Follow up: Could you solve the problem in linear time and in O(1) space?\n2 Solution #  #include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt;class Solution { public:  vector\u0026lt;int\u0026gt; majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  // Runtime complexity: O(n). n is the size of nums.  // Space complexity: O(n).  std::vector\u0026lt;int\u0026gt; result;  if (nums.size() == 0) {  return result;  }   std::unordered_map\u0026lt;int, int\u0026gt; occur;  int threshold = nums.size() / 3;  for (const auto \u0026amp;num : nums) {  auto iter = occur.find(num);  if (iter != occur.end()) { \titer-\u0026gt;second++;  } else { \toccur[num] = 1;  }   if (occur[num] \u0026gt; threshold) { \tresult.emplace_back(num); \t// since num has been added into result, just making it impossible to be \t// added twice. \toccur[num] = -0x709394;  }  }   return result;  } }; "},{"id":19,"href":"/docs/200/231_power_of_two/","title":"231. Power of Two","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/power-of-two/\nGiven an integer n, return true if it is a power of two. Otherwise, return false.\nAn integer n is a power of two, if there exists an integer x such that n == 2^x.\nExample 1:\nInput: n = 1 Output: true Explanation: 20 = 1 Example 2:\nInput: n = 16 Output: true Explanation: 24 = 16 Example 3:\nInput: n = 3 Output: false Constraints:\n -2^31 \u0026lt;= n \u0026lt;= 2^31 - 1  Follow up: Could you solve it without loops/recursion?\n2 Solution #  #include \u0026lt;bitset\u0026gt;class Solution { public:  bool isPowerOfTwo(int n) {  return std::bitset\u0026lt;33\u0026gt;(n).count() == 1;  } }; "},{"id":20,"href":"/docs/200/268_missing_number/","title":"268. Missing Number","section":"200th","content":"1 Description #  source: https://leetcode.com/problems/missing-number/\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nInput: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2:\nInput: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3:\nInput: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints:\n n == nums.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= nums[i] \u0026lt;= n All the numbers of nums are unique.  Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\n2 Solution #  #include \u0026lt;vector\u0026gt;class Solution { public:  int missingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  // Time complexity: O(n), n is the size of nums.  // Space complexity: O(1)  int n = nums.size();  int expected_sum = n * (n + 1) / 2.0;  for(const auto\u0026amp; num: nums){  expected_sum -= num;  }  return expected_sum;  } }; "},{"id":21,"href":"/docs/300/","title":"300th","section":"Docs","content":"1 Leetcode 300-399 #  "},{"id":22,"href":"/docs/300/328_odd_even_linked_list/","title":"328. Odd Even Linked List","section":"300th","content":"1 Description #  source: https://leetcode.com/problems/odd-even-linked-list/ Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExample 1: Input: head = [1,2,3,4,5] Output: [1,3,5,2,4] Example 2: Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] Constraints:\n n == number of nodes in the linked list 0 \u0026lt;= n \u0026lt;= 10^4 -10^6 \u0026lt;= Node.val \u0026lt;= 10^6  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* oddEvenList(ListNode* head) {  // Time complexity: O(N) N is the size of linked list  // Space complexity: O(1)  if(!head){  return head;  }   ListNode* first_even = nullptr;  ListNode* first_odd = nullptr;  ListNode* last_even = nullptr;  ListNode* last_odd = nullptr;  int index = 1;   while(head){  if(index % 2 == 1){ \tfirst_odd = (first_odd ==nullptr? head: first_odd);  \tif(!last_odd){ \tlast_odd = head; \t}else{ \tlast_odd -\u0026gt; next = head; \tlast_odd = last_odd-\u0026gt;next; \t}  } else{ \tfirst_even = (first_even == nullptr? head: first_even);  \tif(!last_even){ \tlast_even = head; \t}else{ \tlast_even -\u0026gt; next = head; \tlast_even = last_even-\u0026gt;next; \t}  }   head = head-\u0026gt; next;  index ++;  }   if(last_even){  last_even -\u0026gt; next = nullptr;  }   if(last_odd){  last_odd -\u0026gt; next = first_even;  }   return first_odd;  } }; "},{"id":23,"href":"/docs/1700/","title":"1700th","section":"Docs","content":"1 Leetcode 1700-1799 #  "},{"id":24,"href":"/docs/1700/1721_swapping_nodes_in_a_linked_list/","title":"1721. Swapping Nodes in a Linked List","section":"1700th","content":"1 Description #  source: https://leetcode.com/problems/swapping-nodes-in-a-linked-list/\nYou are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\nExample 1:\n Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Constraints:\n The number of nodes in the list is n. 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= Node.val \u0026lt;= 100  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* swapNodes(ListNode* head, int k) {  // time complexity: O(2N) = O(N), N = size of linked list  // space compleixty(1)  int size = 0;  ListNode* first = head;  ListNode* kth_from_begin = nullptr;  ListNode* kth_from_end = nullptr;  while(first){  size++;  if(size == k){ \tkth_from_begin = first;  }   first = first-\u0026gt;next;  }    int next_round_size = 0;  first = head;  while(first){  next_round_size++;    if(next_round_size == size - k + 1){ \tkth_from_end = first; \tbreak;  }  first = first-\u0026gt;next;  }   int tmp = kth_from_begin -\u0026gt; val;  kth_from_begin-\u0026gt;val = kth_from_end-\u0026gt;val;  kth_from_end -\u0026gt; val = tmp;   return head;  } }; "},{"id":25,"href":"/docs/2000/","title":"2000th","section":"Docs","content":"1 Leetcode 2000-2099 #  "},{"id":26,"href":"/docs/2000/2095_delete_the_middle_node_of_a_linked_list/","title":"2095. Delete the Middle Node of a Linked List","section":"2000th","content":"1 Description #  source: https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/\nYou are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\nThe middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.\nFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\nExample 1:\n Input: head = [1,3,4,7,1,2,6] Output: [1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. Example 2:\n Input: head = [1,2,3,4] Output: [1,2,4] Explanation: The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. Example 3:\n Input: head = [2,1] Output: [2] Explanation: The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. Constraints:\n The number of nodes in the list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5  2 Solution #    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public:  ListNode* deleteMiddle(ListNode* head) { \t// Time complexity: O(1.5N) = O(N). N is the size of linked list \t// Space complexity: O(1) \tif(!head){ \treturn head; \t}  \tint size = 0; \tListNode* first = head; \twhile(first){ \tsize++; \tfirst = first-\u0026gt;next; \t}  \tif(1 == size){ \treturn nullptr; \t}  \tint middle = size / 2; \tint index = 0; \tfirst = head; \twhile(first){ \tif(index == middle - 1){ \t// the prev node of middle node \tfirst-\u0026gt;next = first-\u0026gt;next-\u0026gt;next; \tbreak; \t}  \tindex ++; \tfirst = first-\u0026gt;next; \t}  \treturn head;  } }; "}]